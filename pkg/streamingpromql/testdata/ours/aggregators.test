# SPDX-License-Identifier: AGPL-3.0-only

# Most cases for aggregation operators are covered already in the upstream test cases.
# These test cases cover scenarios not covered by the upstream test cases, such as range queries, or edge cases that are uniquely likely to cause issues in the streaming engine.

load 1m
  some_metric{env="prod", cluster="eu"} 0+1x4
  some_metric{env="prod", cluster="us"} 0+2x4
  some_metric{env="test", cluster="eu"} 0+3x4
  some_metric{env="test", cluster="us"} 0+4x4

# Range query, aggregating to one group.
eval range from 0 to 4m step 1m sum(some_metric)
  {} 0 10 20 30 40

# Range query, aggregating to multiple groups.
eval range from 0 to 4m step 1m sum by (env) (some_metric)
  {env="prod"} 0 3 6 9 12
  {env="test"} 0 7 14 21 28

# If no series are matched, we shouldn't return any results.
eval range from 0 to 4m step 1m sum(some_nonexistent_metric)
  # Should return no results.

clear

load 1m
  some_metric_with_staleness 1 stale 2

# If no non-stale points are available, we shouldn't return the series at all.
eval range from 1m to 1m30s step 1s sum(some_metric_with_staleness)
  # Should return no results.

clear

# Test native histogram aggregations
load 1m
	single_histogram{label="value"} {{schema:0 sum:2 count:4 buckets:[1 2 1]}} {{sum:2 count:4 buckets:[1 2 1]}}
	single_histogram{label="value2"} {{schema:1 sum:5 count:5 buckets:[1 3 1]}} {{schema:0 sum:2 count:4 buckets:[1 2 1]}}
	single_histogram{label="value2", another="value"} {{schema:1 sum:10 count:9 buckets:[3 3 3]}} {{schema:2 sum:2 count:4 buckets:[1 2 1]}}

eval instant at 0m sum(single_histogram)
	{} {{schema:0 sum:17 count:18 buckets:[5 12 1]}}

eval instant at 0m sum by (label) (single_histogram)
	{label="value"} {{schema:0 count:4 sum:2 buckets:[1 2 1]}}
	{label="value2"} {{schema:1 count:14 sum:15 buckets:[4 6 4]}}

eval range from 0 to 1m step 1m  sum(single_histogram)
	{} {{schema:0 sum:17 count:18 buckets:[5 12 1]}} {{schema:0 sum:6 count:12 buckets:[3 7 2]}}

clear

# Test a mix of float and histogram values
load 1m
	single_histogram{label="value"}                    0 1 {{schema:0 sum:2 count:4 buckets:[1 2 1]}}  {{sum:2 count:4 buckets:[1 2 1]}}          2
	single_histogram{label="value2"}                   0 2 {{schema:1 sum:5 count:5 buckets:[1 3 1]}}  {{schema:0 sum:2 count:4 buckets:[1 2 1]}} 4
	single_histogram{label="value2", another="value"}  0 3 {{schema:1 sum:10 count:9 buckets:[3 3 3]}} {{schema:2 sum:2 count:4 buckets:[1 2 1]}} 6

# TODO: Verify if these tests are correct. At the moment they match promql engine.
# See: https://github.com/prometheus/prometheus/issues/14172

# What I would expect
# eval range from 0 to 4m step 1m  sum by (label) (single_histogram)
#	{label="value"}  0 1 {{count:4 sum:2 buckets:[1 2 1]}}            {{sum:2 count:4 buckets:[1 2 1]}}          2
#	{label="value2"} 0 5 {{schema:1 count:14 sum:15 buckets:[4 6 4]}} {{schema:2 count:8 sum:4 buckets:[4 6 4]}} 10

# What both engines return
eval range from 0 to 4m step 1m  sum by (label) (single_histogram)
	{label="value"}  0 1 1 1 2
	{label="value2"} 0 5 5 5 10
