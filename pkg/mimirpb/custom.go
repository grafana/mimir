// SPDX-License-Identifier: AGPL-3.0-only

package mimirpb

import (
	"bytes"
)

func (h Histogram) IsFloatHistogram() bool {
	return h.GetCountFloat() > 0 || h.GetZeroCountFloat() > 0
}

func (h Histogram) IsGauge() bool {
	return h.ResetHint == Histogram_GAUGE
}

// YoloByteSlice is an alternative to the default handling of []byte values in protobuf messages.
// Unlike the default protobuf implementation, when unmarshalling, YoloByteSlice holds a reference to the
// subslice of the original protobuf-encoded bytes, rather than copying them from the encoded buffer to a second slice.
// This reduces memory pressure when unmarshalling byte slices, at the cost of retaining the full buffer in memory. This
// tradeoff is usually only worthwhile when the protobuf message is dominated by []byte values (eg. when sending chunks
// to queriers).
//
// The implementations of all other methods are identical to those generated by the protobuf compiler.
//
// Note that YoloByteSlice will not behave correctly if the protobuf-encoded bytes are reused (eg. if the
// buffer is used for one request and then pooled and reused for a later request). At the time of writing, the gRPC
// client does not do this, but there is a TODO to investigate it (see
// https://github.com/grafana/mimir/blob/117f0d68785b8a3ca07a8b1dda5a350b17cdc09b/vendor/google.golang.org/grpc/rpc_util.go#L575-L576).
type YoloByteSlice []byte

func (t *YoloByteSlice) MarshalTo(data []byte) (n int, err error) {
	copy(data, *t)

	return t.Size(), nil
}

func (t *YoloByteSlice) Unmarshal(data []byte) error {
	*t = data

	return nil
}

func (t *YoloByteSlice) Size() int {
	return len(*t)
}

func (t YoloByteSlice) Equal(other YoloByteSlice) bool {
	return bytes.Equal(t, other)
}
