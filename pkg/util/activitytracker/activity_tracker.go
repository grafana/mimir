package activitytracker

import (
	"flag"
	"io"
	"os"
	"strings"
	"unicode/utf8"

	"github.com/edsrzf/mmap-go"
	"github.com/go-kit/log"
	"github.com/grafana/dskit/multierror"
	"github.com/pkg/errors"
	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promauto"
)

// ActivityTracker remembers active tasks in the file. If the file already exists, and has any active tasks logged to it,
// these are returned on initialization.
// Activity tracker uses mmap to write to the file, which allows fast writes because it's only using memory access, with
// no system call.
// Nil activity tracker ignores all calls to its public API.
type ActivityTracker struct {
	file            *os.File
	fileBytes       mmap.MMap
	entryIndexQueue chan int // Used as a queue of free indexes.
	logger          log.Logger
	maxEntries      int

	failedInserts prometheus.Counter
}

const (
	entrySize int = 1024
)

var emptyEntry = make([]byte, entrySize)

type Config struct {
	Filename   string `yaml:"filename"`
	MaxEntries int    `yaml:"max_entries"`
}

func (c *Config) RegisterFlags(f *flag.FlagSet) {
	f.StringVar(&c.Filename, "activity-tracker.filename", "", "File where ongoing activities are stored. If empty, activity tracking is disabled.")
	f.IntVar(&c.MaxEntries, "activity-tracker.max-entries", 1024, "Max number of concurrent activities that can be tracked. Used to size file in advance. Additional activities are ignored.")
}

func NewActivityTracker(cfg Config, reg prometheus.Registerer) (*ActivityTracker, error) {
	if cfg.Filename == "" {
		return nil, nil
	}

	filesize := cfg.MaxEntries * entrySize

	file, fileAsBytes, err := getMappedFile(cfg.Filename, filesize)
	if err != nil {
		return nil, err
	}

	tracker := &ActivityTracker{
		file:            file,
		fileBytes:       fileAsBytes,
		entryIndexQueue: make(chan int, cfg.MaxEntries),
		maxEntries:      cfg.MaxEntries,

		failedInserts: promauto.With(reg).NewCounter(prometheus.CounterOpts{
			Name: "activity_tracker_full_total",
			Help: "How many times has activity tracker failed to insert new activity due to being full.",
		}),
	}

	for i := 0; i < cfg.MaxEntries; i++ {
		tracker.entryIndexQueue <- i
	}

	return tracker, nil
}

// Insert inserts entry (generated by entryGenerator) into the activity tracker. If tracker
// is full, entryGenerator is not called. Returned value is to be used with Delete method
// after activity has finished.
//
// String returned by activityGenerator should be human readable description of activity.
// If it is bigger than max entry size, it will be trimmed on latest utf-8 rune start before the limit.
func (t *ActivityTracker) Insert(activityGenerator func() string) (activityIndex int) {
	if t == nil {
		return -1
	}

	select {
	case i := <-t.entryIndexQueue:
		entry := activityGenerator()
		entry = trimEntryToSize(entry, entrySize)

		copy(t.fileBytes[i*entrySize:], entry)
		return i
	default:
		t.failedInserts.Inc()
		return -1
	}
}

func (t *ActivityTracker) InsertStatic(activity string) (activityIndex int) {
	return t.Insert(func() string { return activity })
}

// Delete removes activity with given index (returned previously by Insert) from the tracker.
// Should only be called once for each activity, as indexes are reused.
// It is OK to call Delete with negative index, which is returned by Insert when activity couldn't be inserted.
func (t *ActivityTracker) Delete(activityIndex int) {
	if activityIndex < 0 || activityIndex >= t.maxEntries {
		return
	}

	copy(t.fileBytes[activityIndex*entrySize:], emptyEntry)
	t.entryIndexQueue <- activityIndex
}

func (t *ActivityTracker) flush() error {
	return t.fileBytes.Flush()
}

// Close closes activity tracker. Calling other methods after Close() will likely panic. Don't do that.
func (t *ActivityTracker) Close() error {
	if t == nil {
		return nil
	}

	err1 := t.fileBytes.Unmap()
	err2 := t.file.Close()

	return multierror.New(err1, err2).Err()
}

// Trim entry to given size limit, respecting UTF-8 rune boundaries.
func trimEntryToSize(entry string, size int) string {
	if len(entry) <= size {
		return entry
	}

	l := size
	for !utf8.RuneStart(entry[l]) {
		l--
	}

	return entry[:l]
}

func getMappedFile(filename string, filesize int) (*os.File, mmap.MMap, error) {
	file, err := os.OpenFile(filename, os.O_CREATE|os.O_RDWR|os.O_TRUNC, 0666)
	if err != nil {
		return nil, nil, errors.Wrap(err, "failed to create activity file")
	}

	closeOnReturn := true
	defer func() {
		if closeOnReturn {
			_ = file.Close()
		}
	}()

	err = file.Truncate(int64(filesize))
	if err != nil {
		return nil, nil, errors.Wrap(err, "failed to truncate activity file")
	}

	fileAsBytes, err := mmap.Map(file, mmap.RDWR, 0)
	if err != nil {
		return nil, nil, errors.Wrap(err, "failed to mmap activity file")
	}

	closeOnReturn = false
	return file, fileAsBytes, err
}

// LoadUnfinishedEntries loads and returns list of unfinished activities in the activity file. It's best-effort,
// so all errors are ignored.
func LoadUnfinishedEntries(file string) []string {
	fd, err := os.Open(file)
	if err != nil {
		return nil
	}

	defer func() { _ = fd.Close() }()

	var results []string

	buf := make([]byte, entrySize)
	var n int
	for n, err = io.ReadFull(fd, buf); err == nil; _, err = io.ReadFull(fd, buf) {
		s := string(buf[:n])
		if s != string(emptyEntry) {
			s = strings.ReplaceAll(s, "\x00", "")
			results = append(results, s)
		}
	}

	return results
}
