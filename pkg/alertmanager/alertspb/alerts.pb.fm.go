// GENERATED CODE - DO NOT EDIT
// This file was generated by protoc-gen-fastmarshal

package alertspb

import (
	"fmt"
	"sync/atomic"
	"github.com/CrowdStrike/csproto"
	clusterpb "github.com/prometheus/alertmanager/cluster/clusterpb"
)

//------------------------------------------------------------------------------
// Custom Protobuf size/marshal/unmarshal code for AlertConfigDesc

// Size calculates and returns the size, in bytes, required to hold the contents of m using the Protobuf
// binary encoding.
func (m *AlertConfigDesc) Size() int {
	// nil message is always 0 bytes
	if m == nil {
		return 0
	}
	// return cached size, if present
	if csz := int(atomic.LoadInt32(&m.sizeCache)); csz > 0 {
		return csz
	}
	// calculate and cache
	var sz, l int
	_ = l // avoid unused variable

	// User (string,optional)
	if l = len(m.User); l > 0 {
		sz += csproto.SizeOfTagKey(1) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// RawConfig (string,optional)
	if l = len(m.RawConfig); l > 0 {
		sz += csproto.SizeOfTagKey(2) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// Templates (message,repeated)
	for _, val := range m.Templates {
		if l = csproto.Size(val); l > 0 {
			sz += csproto.SizeOfTagKey(3) + csproto.SizeOfVarint(uint64(l)) + l
		}
	}
	// cache the size so it can be re-used in Marshal()/MarshalTo()
	atomic.StoreInt32(&m.sizeCache, int32(sz))
	return sz
}

// Marshal converts the contents of m to the Protobuf binary encoding and returns the result or an error.
func (m *AlertConfigDesc) Marshal() ([]byte, error) {
	siz := m.Size()
	if siz == 0 {
		return []byte{}, nil
	}
	buf := make([]byte, siz)
	err := m.MarshalTo(buf)
	return buf, err
}

// MarshalTo converts the contents of m to the Protobuf binary encoding and writes the result to dest.
func (m *AlertConfigDesc) MarshalTo(dest []byte) error {
	// nil message == no-op
	if m == nil {
		return nil
	}
	var (
		enc    = csproto.NewEncoder(dest)
		buf    []byte
		err    error
		extVal interface{}
	)
	// ensure no unused variables
	_ = enc
	_ = buf
	_ = err
	_ = extVal

	// User (1,string,optional)
	if len(m.User) > 0 {
		enc.EncodeString(1, m.User)
	}
	// RawConfig (2,string,optional)
	if len(m.RawConfig) > 0 {
		enc.EncodeString(2, m.RawConfig)
	}
	// Templates (3,message,repeated)
	for _, mm := range m.Templates {
		if err = enc.EncodeNested(3, mm); err != nil {
			return fmt.Errorf("unable to encode message data for field 'templates' (tag=3): %w", err)
		}
	}
	return nil
}

// Unmarshal decodes a binary encoded Protobuf message from p and populates m with the result.
func (m *AlertConfigDesc) Unmarshal(p []byte) error {
	m.Reset()
	if len(p) == 0 {
		return nil
	}
	dec := csproto.NewDecoder(p)
	for dec.More() {
		tag, wt, err := dec.DecodeTag()
		if err != nil {
			return err
		}
		switch tag {
		case 1: // User (string,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'user' (tag=1), expected 2 (length-delimited)", wt)
			}
			if s, err := dec.DecodeString(); err != nil {
				return fmt.Errorf("unable to decode string value for field 'user' (tag=1): %w", err)
			} else {
				m.User = s
			}

		case 2: // RawConfig (string,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'raw_config' (tag=2), expected 2 (length-delimited)", wt)
			}
			if s, err := dec.DecodeString(); err != nil {
				return fmt.Errorf("unable to decode string value for field 'raw_config' (tag=2): %w", err)
			} else {
				m.RawConfig = s
			}

		case 3: // Templates (message,repeated)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'templates' (tag=3), expected 2 (length-delimited)", wt)
			}
			var mm TemplateDesc
			if err = dec.DecodeNested(&mm); err != nil {
				return fmt.Errorf("unable to decode message value for field 'templates' (tag=3): %w", err)
			}
			m.Templates = append(m.Templates, &mm)

		default:
			if skipped, err := dec.Skip(tag, wt); err != nil {
				return fmt.Errorf("invalid operation skipping tag %v: %w", tag, err)
			} else {
				m.unknownFields = append(m.unknownFields, skipped...)
			}
		}
	}
	return nil
}

//------------------------------------------------------------------------------
// Custom Protobuf size/marshal/unmarshal code for TemplateDesc

// Size calculates and returns the size, in bytes, required to hold the contents of m using the Protobuf
// binary encoding.
func (m *TemplateDesc) Size() int {
	// nil message is always 0 bytes
	if m == nil {
		return 0
	}
	// return cached size, if present
	if csz := int(atomic.LoadInt32(&m.sizeCache)); csz > 0 {
		return csz
	}
	// calculate and cache
	var sz, l int
	_ = l // avoid unused variable

	// Filename (string,optional)
	if l = len(m.Filename); l > 0 {
		sz += csproto.SizeOfTagKey(1) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// Body (string,optional)
	if l = len(m.Body); l > 0 {
		sz += csproto.SizeOfTagKey(2) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// cache the size so it can be re-used in Marshal()/MarshalTo()
	atomic.StoreInt32(&m.sizeCache, int32(sz))
	return sz
}

// Marshal converts the contents of m to the Protobuf binary encoding and returns the result or an error.
func (m *TemplateDesc) Marshal() ([]byte, error) {
	siz := m.Size()
	if siz == 0 {
		return []byte{}, nil
	}
	buf := make([]byte, siz)
	err := m.MarshalTo(buf)
	return buf, err
}

// MarshalTo converts the contents of m to the Protobuf binary encoding and writes the result to dest.
func (m *TemplateDesc) MarshalTo(dest []byte) error {
	// nil message == no-op
	if m == nil {
		return nil
	}
	var (
		enc    = csproto.NewEncoder(dest)
		buf    []byte
		err    error
		extVal interface{}
	)
	// ensure no unused variables
	_ = enc
	_ = buf
	_ = err
	_ = extVal

	// Filename (1,string,optional)
	if len(m.Filename) > 0 {
		enc.EncodeString(1, m.Filename)
	}
	// Body (2,string,optional)
	if len(m.Body) > 0 {
		enc.EncodeString(2, m.Body)
	}
	return nil
}

// Unmarshal decodes a binary encoded Protobuf message from p and populates m with the result.
func (m *TemplateDesc) Unmarshal(p []byte) error {
	m.Reset()
	if len(p) == 0 {
		return nil
	}
	dec := csproto.NewDecoder(p)
	for dec.More() {
		tag, wt, err := dec.DecodeTag()
		if err != nil {
			return err
		}
		switch tag {
		case 1: // Filename (string,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'filename' (tag=1), expected 2 (length-delimited)", wt)
			}
			if s, err := dec.DecodeString(); err != nil {
				return fmt.Errorf("unable to decode string value for field 'filename' (tag=1): %w", err)
			} else {
				m.Filename = s
			}

		case 2: // Body (string,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'body' (tag=2), expected 2 (length-delimited)", wt)
			}
			if s, err := dec.DecodeString(); err != nil {
				return fmt.Errorf("unable to decode string value for field 'body' (tag=2): %w", err)
			} else {
				m.Body = s
			}

		default:
			if skipped, err := dec.Skip(tag, wt); err != nil {
				return fmt.Errorf("invalid operation skipping tag %v: %w", tag, err)
			} else {
				m.unknownFields = append(m.unknownFields, skipped...)
			}
		}
	}
	return nil
}

//------------------------------------------------------------------------------
// Custom Protobuf size/marshal/unmarshal code for FullStateDesc

// Size calculates and returns the size, in bytes, required to hold the contents of m using the Protobuf
// binary encoding.
func (m *FullStateDesc) Size() int {
	// nil message is always 0 bytes
	if m == nil {
		return 0
	}
	// return cached size, if present
	if csz := int(atomic.LoadInt32(&m.sizeCache)); csz > 0 {
		return csz
	}
	// calculate and cache
	var sz, l int
	_ = l // avoid unused variable

	// State (message,optional)
	if m.State != nil {
		l = csproto.Size(m.State)
		sz += csproto.SizeOfTagKey(1) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// cache the size so it can be re-used in Marshal()/MarshalTo()
	atomic.StoreInt32(&m.sizeCache, int32(sz))
	return sz
}

// Marshal converts the contents of m to the Protobuf binary encoding and returns the result or an error.
func (m *FullStateDesc) Marshal() ([]byte, error) {
	siz := m.Size()
	if siz == 0 {
		return []byte{}, nil
	}
	buf := make([]byte, siz)
	err := m.MarshalTo(buf)
	return buf, err
}

// MarshalTo converts the contents of m to the Protobuf binary encoding and writes the result to dest.
func (m *FullStateDesc) MarshalTo(dest []byte) error {
	// nil message == no-op
	if m == nil {
		return nil
	}
	var (
		enc    = csproto.NewEncoder(dest)
		buf    []byte
		err    error
		extVal interface{}
	)
	// ensure no unused variables
	_ = enc
	_ = buf
	_ = err
	_ = extVal

	// State (1,message,optional)
	if m.State != nil {
		if err = enc.EncodeNested(1, m.State); err != nil {
			return fmt.Errorf("unable to encode message data for field 'state' (tag=1): %w", err)
		}
	}
	return nil
}

// Unmarshal decodes a binary encoded Protobuf message from p and populates m with the result.
func (m *FullStateDesc) Unmarshal(p []byte) error {
	m.Reset()
	if len(p) == 0 {
		return nil
	}
	dec := csproto.NewDecoder(p)
	for dec.More() {
		tag, wt, err := dec.DecodeTag()
		if err != nil {
			return err
		}
		switch tag {
		case 1: // State (message,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'state' (tag=1), expected 2 (length-delimited)", wt)
			}
			var mm clusterpb.FullState
			if err = dec.DecodeNested(&mm); err != nil {
				return fmt.Errorf("unable to decode message value for field 'state' (tag=1): %w", err)
			}
			m.State = &mm

		default:
			if skipped, err := dec.Skip(tag, wt); err != nil {
				return fmt.Errorf("invalid operation skipping tag %v: %w", tag, err)
			} else {
				m.unknownFields = append(m.unknownFields, skipped...)
			}
		}
	}
	return nil
}

//------------------------------------------------------------------------------
// Custom Protobuf size/marshal/unmarshal code for GrafanaAlertConfigDesc

// Size calculates and returns the size, in bytes, required to hold the contents of m using the Protobuf
// binary encoding.
func (m *GrafanaAlertConfigDesc) Size() int {
	// nil message is always 0 bytes
	if m == nil {
		return 0
	}
	// return cached size, if present
	if csz := int(atomic.LoadInt32(&m.sizeCache)); csz > 0 {
		return csz
	}
	// calculate and cache
	var sz, l int
	_ = l // avoid unused variable

	// User (string,optional)
	if l = len(m.User); l > 0 {
		sz += csproto.SizeOfTagKey(1) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// RawConfig (string,optional)
	if l = len(m.RawConfig); l > 0 {
		sz += csproto.SizeOfTagKey(2) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// Hash (string,optional)
	if l = len(m.Hash); l > 0 {
		sz += csproto.SizeOfTagKey(4) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// CreatedAtTimestamp (int64,optional)
	if m.CreatedAtTimestamp != 0 {
		sz += csproto.SizeOfTagKey(5) + csproto.SizeOfVarint(uint64(m.CreatedAtTimestamp))
	}
	// Default (bool,optional)
	if m.Default {
		sz += csproto.SizeOfTagKey(7) + 1
	}
	// Promoted (bool,optional)
	if m.Promoted {
		sz += csproto.SizeOfTagKey(8) + 1
	}
	// ExternalUrl (string,optional)
	if l = len(m.ExternalUrl); l > 0 {
		sz += csproto.SizeOfTagKey(9) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// StaticHeaders (message,repeated)
	for k, v := range m.StaticHeaders {
		// size of key (always has an internal tag of 1)
		l = len(k)
		keySize := 1 + csproto.SizeOfVarint(uint64(l)) + l
		// size of value (always has an internal tag of 2)
		l = len(v)
		valueSize := 1 + csproto.SizeOfVarint(uint64(l)) + l
		sz += csproto.SizeOfTagKey(10) + csproto.SizeOfVarint(uint64(keySize+valueSize)) + keySize + valueSize
	}

	// cache the size so it can be re-used in Marshal()/MarshalTo()
	atomic.StoreInt32(&m.sizeCache, int32(sz))
	return sz
}

// Marshal converts the contents of m to the Protobuf binary encoding and returns the result or an error.
func (m *GrafanaAlertConfigDesc) Marshal() ([]byte, error) {
	siz := m.Size()
	if siz == 0 {
		return []byte{}, nil
	}
	buf := make([]byte, siz)
	err := m.MarshalTo(buf)
	return buf, err
}

// MarshalTo converts the contents of m to the Protobuf binary encoding and writes the result to dest.
func (m *GrafanaAlertConfigDesc) MarshalTo(dest []byte) error {
	// nil message == no-op
	if m == nil {
		return nil
	}
	var (
		enc    = csproto.NewEncoder(dest)
		buf    []byte
		err    error
		extVal interface{}
	)
	// ensure no unused variables
	_ = enc
	_ = buf
	_ = err
	_ = extVal

	// User (1,string,optional)
	if len(m.User) > 0 {
		enc.EncodeString(1, m.User)
	}
	// RawConfig (2,string,optional)
	if len(m.RawConfig) > 0 {
		enc.EncodeString(2, m.RawConfig)
	}
	// Hash (4,string,optional)
	if len(m.Hash) > 0 {
		enc.EncodeString(4, m.Hash)
	}
	// CreatedAtTimestamp (5,int64,optional)
	if m.CreatedAtTimestamp != 0 {
		enc.EncodeInt64(5, m.CreatedAtTimestamp)
	}
	// Default (7,bool,optional)
	if m.Default {
		enc.EncodeBool(7, m.Default)
	}
	// Promoted (8,bool,optional)
	if m.Promoted {
		enc.EncodeBool(8, m.Promoted)
	}
	// ExternalUrl (9,string,optional)
	if len(m.ExternalUrl) > 0 {
		enc.EncodeString(9, m.ExternalUrl)
	}
	// StaticHeaders (10,map)
	for k, v := range m.StaticHeaders {
		valueSize := len(v)
		itemSize := 1 + csproto.SizeOfVarint(uint64(valueSize)) + valueSize
		keySize := len(k)
		itemSize += 1 + csproto.SizeOfVarint(uint64(keySize)) + keySize
		enc.EncodeMapEntryHeader(10, itemSize)
		enc.EncodeString(1, k)
		enc.EncodeString(2, v)
	}

	return nil
}

// Unmarshal decodes a binary encoded Protobuf message from p and populates m with the result.
func (m *GrafanaAlertConfigDesc) Unmarshal(p []byte) error {
	m.Reset()
	if len(p) == 0 {
		return nil
	}
	dec := csproto.NewDecoder(p)
	for dec.More() {
		tag, wt, err := dec.DecodeTag()
		if err != nil {
			return err
		}
		switch tag {
		case 1: // User (string,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'user' (tag=1), expected 2 (length-delimited)", wt)
			}
			if s, err := dec.DecodeString(); err != nil {
				return fmt.Errorf("unable to decode string value for field 'user' (tag=1): %w", err)
			} else {
				m.User = s
			}

		case 2: // RawConfig (string,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'raw_config' (tag=2), expected 2 (length-delimited)", wt)
			}
			if s, err := dec.DecodeString(); err != nil {
				return fmt.Errorf("unable to decode string value for field 'raw_config' (tag=2): %w", err)
			} else {
				m.RawConfig = s
			}

		case 4: // Hash (string,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'hash' (tag=4), expected 2 (length-delimited)", wt)
			}
			if s, err := dec.DecodeString(); err != nil {
				return fmt.Errorf("unable to decode string value for field 'hash' (tag=4): %w", err)
			} else {
				m.Hash = s
			}

		case 5: // CreatedAtTimestamp (int64,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'created_at_timestamp' (tag=5), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt64(); err != nil {
				return fmt.Errorf("unable to decode int64 value for field 'created_at_timestamp' (tag=5): %w", err)
			} else {
				m.CreatedAtTimestamp = v
			}
		case 7: // Default (bool,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'default' (tag=7), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeBool(); err != nil {
				return fmt.Errorf("unable to decode boolean value for field 'default' (tag=7): %w", err)
			} else {
				m.Default = v
			}
		case 8: // Promoted (bool,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'promoted' (tag=8), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeBool(); err != nil {
				return fmt.Errorf("unable to decode boolean value for field 'promoted' (tag=8): %w", err)
			} else {
				m.Promoted = v
			}
		case 9: // ExternalUrl (string,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'external_url' (tag=9), expected 2 (length-delimited)", wt)
			}
			if s, err := dec.DecodeString(); err != nil {
				return fmt.Errorf("unable to decode string value for field 'external_url' (tag=9): %w", err)
			} else {
				m.ExternalUrl = s
			}

		case 10: // StaticHeaders (map)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for map field 'static_headers' (tag=10), expected 2 (length-delimited)", wt)
			}

			if m.StaticHeaders == nil {
				m.StaticHeaders = make(map[string]string)
			}
			// consume the map entry size
			// TODO - should we validate this?
			if _, err = dec.DecodeInt32(); err != nil {
				return err
			}
			// always 2 values
			var (
				entryKey   string
				entryValue string
			)
			for i := 0; i < 2; i++ {
				etag, ewt, err := dec.DecodeTag()
				if err != nil {
					return err
				}
				switch etag {
				case 1: // key
					if ewt != csproto.WireTypeLengthDelimited {
						return fmt.Errorf("incorrect wire type %v for map key for field 'static_headers' (tag=10), expected 2 (length-delimited)", ewt)
					}
					if entryKey, err = dec.DecodeString(); err != nil {
						return err
					}
				case 2: // value
					if ewt != csproto.WireTypeLengthDelimited {
						return fmt.Errorf("incorrect wire type %v for map value for field 'static_headers' (tag=10), expected 2 (length-delimited)", ewt)
					}
					if entryValue, err = dec.DecodeString(); err != nil {
						return err
					}
				default:
					return fmt.Errorf("invalid map entry field tag %d, expected 1 or 2", etag)
				}
			}
			m.StaticHeaders[entryKey] = entryValue

		default:
			if skipped, err := dec.Skip(tag, wt); err != nil {
				return fmt.Errorf("invalid operation skipping tag %v: %w", tag, err)
			} else {
				m.unknownFields = append(m.unknownFields, skipped...)
			}
		}
	}
	return nil
}
