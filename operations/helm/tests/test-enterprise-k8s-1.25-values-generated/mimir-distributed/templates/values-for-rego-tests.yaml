---
# Source: mimir-distributed/templates/values-for-rego-tests.yaml
apiVersion: v1
kind: Values
spec:
  admin-cache:
    affinity: {}
    allocatedMemory: 64
    annotations: {}
    enabled: false
    extraArgs: {}
    extraContainers: []
    initContainers: []
    maxItemMemory: 1
    nodeSelector: {}
    podAnnotations: {}
    podDisruptionBudget: {}
    podLabels: {}
    podManagementPolicy: Parallel
    port: 11211
    priorityClassName: null
    replicas: 1
    resources: null
    service:
      annotations: {}
      labels: {}
    statefulStrategy:
      type: RollingUpdate
    terminationGracePeriodSeconds: 60
    tolerations: []
    topologySpreadConstraints: {}
  admin_api:
    affinity: {}
    annotations: {}
    containerSecurityContext:
      allowPrivilegeEscalation: false
      capabilities:
        drop:
        - ALL
      readOnlyRootFilesystem: true
    env: []
    extraArgs: {}
    extraContainers: []
    extraEnvFrom: []
    extraVolumeMounts: []
    extraVolumes: []
    initContainers: []
    nodeSelector: {}
    persistence:
      subPath: null
    podAnnotations: {}
    podDisruptionBudget: {}
    podLabels: {}
    priorityClassName: null
    readinessProbe:
      httpGet:
        path: /ready
        port: http-metrics
      initialDelaySeconds: 45
    replicas: 1
    resources:
      requests:
        cpu: 10m
        memory: 32Mi
    securityContext: {}
    service:
      annotations: {}
      labels: {}
    strategy:
      type: RollingUpdate
    terminationGracePeriodSeconds: 60
    tolerations: []
    topologySpreadConstraints:
      maxSkew: 1
      topologyKey: kubernetes.io/hostname
      whenUnsatisfiable: ScheduleAnyway
  alertmanager:
    affinity: {}
    annotations: {}
    containerSecurityContext:
      allowPrivilegeEscalation: false
      capabilities:
        drop:
        - ALL
      readOnlyRootFilesystem: true
    enabled: true
    env: []
    extraArgs: {}
    extraContainers: []
    extraEnvFrom: []
    extraVolumeMounts: []
    extraVolumes: []
    fallbackConfig: |
      receivers:
          - name: default-receiver
      route:
          receiver: default-receiver
    initContainers: []
    nodeSelector: {}
    persistence:
      subPath: null
    persistentVolume:
      accessModes:
      - ReadWriteOnce
      annotations: {}
      enabled: true
      size: 1Gi
      subPath: ""
    podAnnotations: {}
    podDisruptionBudget: {}
    podLabels: {}
    priorityClassName: null
    readinessProbe:
      httpGet:
        path: /ready
        port: http-metrics
      initialDelaySeconds: 45
    replicas: 1
    resources:
      requests:
        cpu: 10m
        memory: 32Mi
    schedulerName: ""
    securityContext: {}
    service:
      annotations: {}
      labels: {}
    statefulSet:
      enabled: true
    statefulStrategy:
      type: RollingUpdate
    strategy:
      rollingUpdate:
        maxSurge: 0
        maxUnavailable: 1
      type: RollingUpdate
    terminationGracePeriodSeconds: 60
    tolerations: []
    topologySpreadConstraints:
      maxSkew: 1
      topologyKey: kubernetes.io/hostname
      whenUnsatisfiable: ScheduleAnyway
    zoneAwareReplication:
      enabled: false
      maxUnavailable: 2
      migration:
        enabled: false
        writePath: false
      topologyKey: null
      zones:
      - extraAffinity: {}
        name: zone-a
        nodeSelector: null
      - extraAffinity: {}
        name: zone-b
        nodeSelector: null
      - extraAffinity: {}
        name: zone-c
        nodeSelector: null
  chunks-cache:
    affinity: {}
    allocatedMemory: 8192
    annotations: {}
    enabled: false
    extraArgs: {}
    extraContainers: []
    initContainers: []
    maxItemMemory: 1
    nodeSelector: {}
    podAnnotations: {}
    podDisruptionBudget: {}
    podLabels: {}
    podManagementPolicy: Parallel
    port: 11211
    priorityClassName: null
    replicas: 1
    resources: null
    service:
      annotations: {}
      labels: {}
    statefulStrategy:
      type: RollingUpdate
    terminationGracePeriodSeconds: 60
    tolerations: []
    topologySpreadConstraints: {}
  compactor:
    affinity: {}
    annotations: {}
    containerSecurityContext:
      allowPrivilegeEscalation: false
      capabilities:
        drop:
        - ALL
      readOnlyRootFilesystem: true
    env: []
    extraArgs: {}
    extraContainers: []
    extraEnvFrom: []
    extraVolumeMounts: []
    extraVolumes: []
    initContainers: []
    nodeSelector: {}
    persistentVolume:
      accessModes:
      - ReadWriteOnce
      annotations: {}
      enabled: true
      size: 2Gi
      subPath: ""
    podAnnotations: {}
    podDisruptionBudget: {}
    podLabels: {}
    priorityClassName: null
    readinessProbe:
      httpGet:
        path: /ready
        port: http-metrics
      initialDelaySeconds: 60
    replicas: 1
    resources:
      requests:
        cpu: 100m
        memory: 512Mi
    schedulerName: ""
    securityContext: {}
    service:
      annotations: {}
      labels: {}
    strategy:
      type: RollingUpdate
    terminationGracePeriodSeconds: 240
    tolerations: []
    topologySpreadConstraints:
      maxSkew: 1
      topologyKey: kubernetes.io/hostname
      whenUnsatisfiable: ScheduleAnyway
  configStorageType: ConfigMap
  continuous_test:
    affinity: {}
    annotations: {}
    auth:
      bearerToken: null
      password: null
      tenant: mimir-continuous-test
      type: tenantId
    containerSecurityContext:
      readOnlyRootFilesystem: true
    enabled: false
    env: []
    extraArgs: {}
    extraContainers: []
    extraEnvFrom: []
    extraVolumeMounts: []
    extraVolumes: []
    image:
      pullPolicy: IfNotPresent
      repository: grafana/mimir-continuous-test
      tag: r228-651a8ed
    initContainers: []
    maxQueryAge: 48h
    nodeSelector: {}
    numSeries: 1000
    priorityClassName: null
    replicas: 1
    resources:
      limits:
        memory: 1Gi
      requests:
        cpu: "1"
        memory: 512Mi
    runInterval: 5m
    securityContext: {}
    service:
      annotations: {}
      labels: {}
    strategy:
      rollingUpdate:
        maxSurge: 0
        maxUnavailable: 1
      type: RollingUpdate
    terminationGracePeriodSeconds: 30
    tolerations: []
  distributor:
    affinity: {}
    annotations: {}
    containerSecurityContext:
      allowPrivilegeEscalation: false
      capabilities:
        drop:
        - ALL
      readOnlyRootFilesystem: true
    env: []
    extraArgs: {}
    extraContainers: []
    extraEnvFrom: []
    extraVolumeMounts: []
    extraVolumes: []
    initContainers: []
    nodeSelector: {}
    persistence:
      subPath: null
    podAnnotations: {}
    podDisruptionBudget: {}
    podLabels: {}
    priorityClassName: null
    readinessProbe:
      httpGet:
        path: /ready
        port: http-metrics
      initialDelaySeconds: 45
    replicas: 1
    resources:
      requests:
        cpu: 100m
        memory: 512Mi
    securityContext: {}
    service:
      annotations: {}
      labels: {}
    strategy:
      type: RollingUpdate
    terminationGracePeriodSeconds: 60
    tolerations: []
    topologySpreadConstraints:
      maxSkew: 1
      topologyKey: kubernetes.io/hostname
      whenUnsatisfiable: ScheduleAnyway
  enterprise:
    enabled: true
    image:
      repository: grafana/enterprise-metrics
      tag: r228-958acda4
    legacyLabels: false
  externalConfigSecretName: '{{ include "mimir.resourceName" (dict "ctx" . "component"
    "config") }}'
  externalConfigVersion: "0"
  extraObjects: []
  fullnameOverride: null
  gateway:
    affinity: {}
    annotations: {}
    autoscaling:
      enabled: false
      maxReplicas: 3
      minReplicas: 1
      targetCPUUtilizationPercentage: 70
      targetMemoryUtilizationPercentage: 70
    containerSecurityContext:
      allowPrivilegeEscalation: false
      capabilities:
        drop:
        - ALL
      readOnlyRootFilesystem: true
    enabledNonEnterprise: false
    env: []
    extraArgs: {}
    extraContainers: []
    extraEnvFrom: []
    extraVolumeMounts: []
    extraVolumes: []
    ingress:
      annotations: {}
      enabled: false
      hosts:
      - host: mimir.example.com
        paths:
        - path: /
      ingressClassName: ""
      nameOverride: ""
      tls:
      - hosts:
        - mimir.example.com
        secretName: mimir-tls
    initContainers: []
    nginx:
      basicAuth:
        enabled: false
        existingSecret: null
        htpasswd: '{{ htpasswd (required "''gateway.nginx.basicAuth.username'' is required"
          .Values.gateway.nginx.basicAuth.username) (required "''gateway.nginx.basicAuth.password''
          is required" .Values.gateway.nginx.basicAuth.password) }}'
        password: null
        username: null
      config:
        accessLogEnabled: true
        errorLogLevel: error
        file: |
          worker_processes  5;  ## Default: 1
          error_log  /dev/stderr {{ .Values.gateway.nginx.config.errorLogLevel }};
          pid        /tmp/nginx.pid;
          worker_rlimit_nofile 8192;
  
          events {
            worker_connections  4096;  ## Default: 1024
          }
  
          http {
            client_body_temp_path /tmp/client_temp;
            proxy_temp_path       /tmp/proxy_temp_path;
            fastcgi_temp_path     /tmp/fastcgi_temp;
            uwsgi_temp_path       /tmp/uwsgi_temp;
            scgi_temp_path        /tmp/scgi_temp;
  
            default_type application/octet-stream;
            log_format   {{ .Values.gateway.nginx.config.logFormat }}
  
            {{- if .Values.gateway.nginx.verboseLogging }}
            access_log   /dev/stderr  main;
            {{- else }}
  
            map $status $loggable {
              ~^[23]  0;
              default 1;
            }
            access_log   {{ .Values.gateway.nginx.config.accessLogEnabled | ternary "/dev/stderr  main  if=$loggable;" "off;" }}
            {{- end }}
  
            sendfile     on;
            tcp_nopush   on;
  
            {{- if .Values.gateway.nginx.config.resolver }}
            resolver {{ .Values.gateway.nginx.config.resolver }};
            {{- else }}
            resolver {{ .Values.global.dnsService }}.{{ .Values.global.dnsNamespace }}.svc.{{ .Values.global.clusterDomain }};
            {{- end }}
  
            {{- with .Values.gateway.nginx.config.httpSnippet }}
            {{ . | nindent 2 }}
            {{- end }}
  
            # Ensure that X-Scope-OrgID is always present, default to the no_auth_tenant for backwards compatibility when multi-tenancy was turned off.
            map $http_x_scope_orgid $ensured_x_scope_orgid {
              default $http_x_scope_orgid;
              "" "{{ include "mimir.noAuthTenant" . }}";
            }
  
            server {
              listen {{ include "mimir.serverHttpListenPort" . }};
  
              {{- if .Values.gateway.nginx.basicAuth.enabled }}
              auth_basic           "Mimir";
              auth_basic_user_file /etc/nginx/secrets/.htpasswd;
              {{- end }}
  
              location = / {
                return 200 'OK';
                auth_basic off;
              }
  
              location = /ready {
                return 200 'OK';
                auth_basic off;
              }
  
              proxy_set_header X-Scope-OrgID $ensured_x_scope_orgid;
  
              # Distributor endpoints
              location /distributor {
                set $distributor {{ template "mimir.fullname" . }}-distributor-headless.{{ .Release.Namespace }}.svc.{{ .Values.global.clusterDomain }};
                proxy_pass      http://$distributor:{{ include "mimir.serverHttpListenPort" . }}$request_uri;
              }
              location = /api/v1/push {
                set $distributor {{ template "mimir.fullname" . }}-distributor-headless.{{ .Release.Namespace }}.svc.{{ .Values.global.clusterDomain }};
                proxy_pass      http://$distributor:{{ include "mimir.serverHttpListenPort" . }}$request_uri;
              }
              location /otlp/v1/metrics {
                set $distributor {{ template "mimir.fullname" . }}-distributor-headless.{{ .Release.Namespace }}.svc.{{ .Values.global.clusterDomain }};
                proxy_pass      http://$distributor:{{ include "mimir.serverHttpListenPort" . }}$request_uri;
              }
  
              # Alertmanager endpoints
              location {{ template "mimir.alertmanagerHttpPrefix" . }} {
                set $alertmanager {{ template "mimir.fullname" . }}-alertmanager-headless.{{ .Release.Namespace }}.svc.{{ .Values.global.clusterDomain }};
                proxy_pass      http://$alertmanager:{{ include "mimir.serverHttpListenPort" . }}$request_uri;
              }
              location = /multitenant_alertmanager/status {
                set $alertmanager {{ template "mimir.fullname" . }}-alertmanager-headless.{{ .Release.Namespace }}.svc.{{ .Values.global.clusterDomain }};
                proxy_pass      http://$alertmanager:{{ include "mimir.serverHttpListenPort" . }}$request_uri;
              }
              location = /api/v1/alerts {
                set $alertmanager {{ template "mimir.fullname" . }}-alertmanager-headless.{{ .Release.Namespace }}.svc.{{ .Values.global.clusterDomain }};
                proxy_pass      http://$alertmanager:{{ include "mimir.serverHttpListenPort" . }}$request_uri;
              }
  
              # Ruler endpoints
              location {{ template "mimir.prometheusHttpPrefix" . }}/config/v1/rules {
                set $ruler {{ template "mimir.fullname" . }}-ruler.{{ .Release.Namespace }}.svc.{{ .Values.global.clusterDomain }};
                proxy_pass      http://$ruler:{{ include "mimir.serverHttpListenPort" . }}$request_uri;
              }
              location {{ template "mimir.prometheusHttpPrefix" . }}/api/v1/rules {
                set $ruler {{ template "mimir.fullname" . }}-ruler.{{ .Release.Namespace }}.svc.{{ .Values.global.clusterDomain }};
                proxy_pass      http://$ruler:{{ include "mimir.serverHttpListenPort" . }}$request_uri;
              }
  
              location {{ template "mimir.prometheusHttpPrefix" . }}/api/v1/alerts {
                set $ruler {{ template "mimir.fullname" . }}-ruler.{{ .Release.Namespace }}.svc.{{ .Values.global.clusterDomain }};
                proxy_pass      http://$ruler:{{ include "mimir.serverHttpListenPort" . }}$request_uri;
              }
              location = /ruler/ring {
                set $ruler {{ template "mimir.fullname" . }}-ruler.{{ .Release.Namespace }}.svc.{{ .Values.global.clusterDomain }};
                proxy_pass      http://$ruler:{{ include "mimir.serverHttpListenPort" . }}$request_uri;
              }
  
              # Rest of {{ template "mimir.prometheusHttpPrefix" . }} goes to the query frontend
              location {{ template "mimir.prometheusHttpPrefix" . }} {
                set $query_frontend {{ template "mimir.fullname" . }}-query-frontend.{{ .Release.Namespace }}.svc.{{ .Values.global.clusterDomain }};
                proxy_pass      http://$query_frontend:{{ include "mimir.serverHttpListenPort" . }}$request_uri;
              }
  
              # Buildinfo endpoint can go to any component
              location = /api/v1/status/buildinfo {
                set $query_frontend {{ template "mimir.fullname" . }}-query-frontend.{{ .Release.Namespace }}.svc.{{ .Values.global.clusterDomain }};
                proxy_pass      http://$query_frontend:{{ include "mimir.serverHttpListenPort" . }}$request_uri;
              }
  
              # Compactor endpoint for uploading blocks
              location /api/v1/upload/block/ {
                set $compactor {{ template "mimir.fullname" . }}-compactor.{{ .Release.Namespace }}.svc.{{ .Values.global.clusterDomain }};
                proxy_pass      http://$compactor:{{ include "mimir.serverHttpListenPort" . }}$request_uri;
              }
  
              {{- with .Values.gateway.nginx.config.serverSnippet }}
              {{ . | nindent 4 }}
              {{- end }}
            }
          }
        httpSnippet: ""
        logFormat: |-
          main '$remote_addr - $remote_user [$time_local]  $status '
                  '"$request" $body_bytes_sent "$http_referer" '
                  '"$http_user_agent" "$http_x_forwarded_for"';
        resolver: null
        serverSnippet: ""
      image:
        registry: docker.io
        repository: nginxinc/nginx-unprivileged
        tag: 1.22-alpine
      verboseLogging: true
    nodeSelector: {}
    podAnnotations: {}
    podDisruptionBudget: {}
    podLabels: {}
    priorityClassName: null
    readinessProbe:
      httpGet:
        path: /ready
        port: http-metrics
      initialDelaySeconds: 15
      timeoutSeconds: 1
    replicas: 1
    resources: {}
    route:
      annotations: {}
      enabled: false
      host: mimir.example.com
      tls:
        termination: edge
    securityContext: {}
    service:
      annotations: {}
      clusterIP: null
      labels: {}
      legacyPort: 8080
      loadBalancerIP: null
      nameOverride: ""
      nodePort: null
      port: 80
      type: ClusterIP
    strategy:
      type: RollingUpdate
    terminationGracePeriodSeconds: 30
    tolerations: []
    topologySpreadConstraints:
      maxSkew: 1
      topologyKey: kubernetes.io/hostname
      whenUnsatisfiable: ScheduleAnyway
  global:
    clusterDomain: cluster.local
    dnsNamespace: kube-system
    dnsService: kube-dns
    extraEnv: []
    extraEnvFrom: []
    podAnnotations: {}
  gr-aggr-cache:
    affinity: {}
    allocatedMemory: 8192
    annotations: {}
    enabled: true
    extraArgs: {}
    extraContainers: []
    initContainers: []
    maxItemMemory: 1
    nodeSelector: {}
    podAnnotations: {}
    podDisruptionBudget: {}
    podLabels: {}
    podManagementPolicy: Parallel
    port: 11211
    priorityClassName: null
    replicas: 1
    resources: null
    service:
      annotations: {}
      labels: {}
    statefulStrategy:
      type: RollingUpdate
    terminationGracePeriodSeconds: 60
    tolerations: []
  gr-metricname-cache:
    affinity: {}
    allocatedMemory: 8192
    annotations: {}
    enabled: true
    extraArgs: {}
    extraContainers: []
    initContainers: []
    maxItemMemory: 1
    nodeSelector: {}
    podAnnotations: {}
    podDisruptionBudget: {}
    podLabels: {}
    podManagementPolicy: Parallel
    port: 11211
    priorityClassName: null
    replicas: 1
    resources: null
    service:
      annotations: {}
      labels: {}
    statefulStrategy:
      type: RollingUpdate
    terminationGracePeriodSeconds: 60
    tolerations: []
  grafana-agent-operator:
    affinity: {}
    annotations: {}
    containerSecurityContext:
      allowPrivilegeEscalation: false
      capabilities:
        drop:
        - ALL
      readOnlyRootFilesystem: true
    extraArgs: []
    fullnameOverride: ""
    global:
      clusterDomain: cluster.local
      dnsNamespace: kube-system
      dnsService: kube-dns
      extraEnv: []
      extraEnvFrom: []
      podAnnotations: {}
    image:
      pullPolicy: IfNotPresent
      pullSecrets: []
      registry: docker.io
      repository: grafana/agent-operator
      tag: v0.28.0
    kubeletService:
      namespace: default
      serviceName: kubelet
    nameOverride: ""
    nodeSelector: {}
    podAnnotations: {}
    podLabels: {}
    podSecurityContext:
      fsGroup: 10001
      runAsGroup: 10001
      runAsNonRoot: true
      runAsUser: 10001
      seccompProfile:
        type: RuntimeDefault
    rbac:
      create: true
      podSecurityPolicyName: ""
    resources: {}
    serviceAccount:
      create: true
      name: null
    tolerations: []
  graphite:
    enabled: false
    querier:
      affinity:
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
          - podAffinityTerm:
              labelSelector:
                matchExpressions:
                - key: app.kubernetes.io/component
                  operator: In
                  values:
                  - graphite-querier
              topologyKey: kubernetes.io/hostname
            weight: 100
      annotations: {}
      containerSecurityContext:
        allowPrivilegeEscalation: false
        capabilities:
          drop:
          - ALL
        readOnlyRootFilesystem: true
      env: []
      extraArgs: {}
      extraContainers: []
      extraEnvFrom: []
      extraVolumeMounts: []
      extraVolumes: []
      initContainers: []
      livenessProbe:
        httpGet:
          path: /ready
          port: http-metrics
        initialDelaySeconds: 45
      nodeSelector: {}
      persistence:
        subPath: null
      podAnnotations: {}
      podDisruptionBudget: {}
      podLabels: {}
      priorityClassName: null
      readinessProbe:
        httpGet:
          path: /ready
          port: http-metrics
        initialDelaySeconds: 45
      replicas: 2
      resources:
        requests:
          cpu: 100m
          memory: 128Mi
      schemasConfiguration:
        storageAggregations: |-
          [default]
          aggregationMethod = avg
          pattern = .*
          xFilesFactor = 0.1
        storageSchemas: |-
          [default]
          pattern = .*
          intervals = 0:1s
          retentions = 10s:8d,10min:1y
      securityContext: {}
      service:
        annotations: {}
        labels: {}
      strategy:
        type: RollingUpdate
      terminationGracePeriodSeconds: 180
      tolerations: []
    web:
      affinity:
        podAntiAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
          - labelSelector:
              matchExpressions:
              - key: app.kubernetes.io/component
                operator: In
                values:
                - graphite-web
            topologyKey: kubernetes.io/hostname
      containerSecurityContext:
        allowPrivilegeEscalation: false
        capabilities:
          drop:
          - ALL
        readOnlyRootFilesystem: true
      image:
        pullPolicy: IfNotPresent
        repository: docker.io/raintank/graphite-mt
        tag: 8-7ebde4c60-v2
      nodeSelector: {}
      podAnnotations: {}
      podDisruptionBudget: {}
      podLabels: {}
      priorityClassName: null
      replicas: 1
      resources:
        requests:
          cpu: 100m
          memory: 512Mi
      securityContext: {}
      service:
        annotations: {}
        labels: {}
      strategy:
        type: RollingUpdate
      terminationGracePeriodSeconds: 30
      tolerations: []
    write_proxy:
      affinity:
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
          - podAffinityTerm:
              labelSelector:
                matchExpressions:
                - key: app.kubernetes.io/component
                  operator: In
                  values:
                  - graphite-write-proxy
              topologyKey: kubernetes.io/hostname
            weight: 100
      annotations: {}
      containerSecurityContext:
        allowPrivilegeEscalation: false
        capabilities:
          drop:
          - ALL
        readOnlyRootFilesystem: true
      env: []
      extraArgs: {}
      extraContainers: []
      extraEnvFrom: []
      extraVolumeMounts: []
      extraVolumes: []
      initContainers: []
      livenessProbe:
        httpGet:
          path: /ready
          port: http-metrics
        initialDelaySeconds: 45
      nodeSelector: {}
      persistence:
        subPath: null
      podAnnotations: {}
      podDisruptionBudget: {}
      podLabels: {}
      priorityClassName: null
      readinessProbe:
        httpGet:
          path: /ready
          port: http-metrics
        initialDelaySeconds: 45
      replicas: 2
      resources:
        requests:
          cpu: 100m
          memory: 128Mi
      securityContext: {}
      service:
        annotations: {}
        labels: {}
      strategy:
        type: RollingUpdate
      terminationGracePeriodSeconds: 180
      tolerations: []
  image:
    pullPolicy: IfNotPresent
    repository: grafana/mimir
    tag: r228-651a8ed
  index-cache:
    affinity: {}
    allocatedMemory: 2048
    annotations: {}
    enabled: false
    extraArgs: {}
    extraContainers: []
    initContainers: []
    maxItemMemory: 5
    nodeSelector: {}
    podAnnotations: {}
    podDisruptionBudget: {}
    podLabels: {}
    podManagementPolicy: Parallel
    port: 11211
    priorityClassName: null
    replicas: 1
    resources: null
    service:
      annotations: {}
      labels: {}
    statefulStrategy:
      type: RollingUpdate
    terminationGracePeriodSeconds: 60
    tolerations: []
    topologySpreadConstraints: {}
  ingester:
    affinity: {}
    annotations: {}
    containerSecurityContext:
      allowPrivilegeEscalation: false
      capabilities:
        drop:
        - ALL
      readOnlyRootFilesystem: true
    env: []
    extraArgs: {}
    extraContainers: []
    extraEnvFrom: []
    extraVolumeMounts: []
    extraVolumes: []
    initContainers: []
    nodeSelector: {}
    persistentVolume:
      accessModes:
      - ReadWriteOnce
      annotations: {}
      enabled: true
      size: 2Gi
      subPath: ""
    podAnnotations: {}
    podDisruptionBudget:
      maxUnavailable: 1
    podLabels: {}
    podManagementPolicy: Parallel
    priorityClassName: null
    readinessProbe:
      httpGet:
        path: /ready
        port: http-metrics
      initialDelaySeconds: 60
    replicas: 3
    resources:
      requests:
        cpu: 100m
        memory: 512Mi
    schedulerName: ""
    securityContext: {}
    service:
      annotations: {}
      labels: {}
    statefulSet:
      enabled: true
    statefulStrategy:
      type: RollingUpdate
    terminationGracePeriodSeconds: 240
    tolerations: []
    topologySpreadConstraints:
      maxSkew: 1
      topologyKey: kubernetes.io/hostname
      whenUnsatisfiable: ScheduleAnyway
    zoneAwareReplication:
      enabled: true
      maxUnavailable: 25
      migration:
        enabled: false
        excludeDefaultZone: false
        readPath: false
        replicas: 0
        scaleDownDefaultZone: false
        writePath: false
      topologyKey: null
      zones:
      - extraAffinity: {}
        name: zone-a
        nodeSelector: null
      - extraAffinity: {}
        name: zone-b
        nodeSelector: null
      - extraAffinity: {}
        name: zone-c
        nodeSelector: null
  kubeVersionOverride: "1.25"
  license:
    contents: NOTAVALIDLICENSE
    external: false
    secretName: '{{ include "mimir.resourceName" (dict "ctx" . "component" "license")
      }}'
  memcached:
    containerSecurityContext:
      allowPrivilegeEscalation: false
      capabilities:
        drop:
        - ALL
      readOnlyRootFilesystem: true
    image:
      pullPolicy: IfNotPresent
      repository: memcached
      tag: 1.6.17-alpine
    podSecurityContext: {}
    priorityClassName: null
  memcachedExporter:
    containerSecurityContext:
      allowPrivilegeEscalation: false
      capabilities:
        drop:
        - ALL
      readOnlyRootFilesystem: true
    enabled: true
    image:
      pullPolicy: IfNotPresent
      repository: prom/memcached-exporter
      tag: v0.6.0
    resources:
      limits: {}
      requests: {}
  metaMonitoring:
    grafanaAgent:
      annotations: {}
      containerSecurityContext: null
      enabled: false
      installOperator: false
      labels: {}
      logs:
        additionalClientConfigs: []
        enabled: true
        remote:
          auth:
            passwordSecretKey: ""
            passwordSecretName: ""
            tenantId: ""
            username: ""
          url: ""
      metrics:
        additionalRemoteWriteConfigs: []
        enabled: true
        remote:
          auth:
            passwordSecretKey: ""
            passwordSecretName: ""
            username: ""
          headers: {}
          url: ""
        scrapeInterval: 60s
        scrapeK8s:
          enabled: true
          kubeStateMetrics:
            labelSelectors:
              app.kubernetes.io/name: kube-state-metrics
            namespace: kube-system
      namespace: ""
      podSecurityContext: null
    prometheusRule:
      annotations: {}
      enabled: false
      groups: []
      labels: {}
      mimirAlerts: false
      mimirRules: false
      namespace: null
    serviceMonitor:
      annotations: {}
      clusterLabel: ""
      enabled: false
      interval: null
      labels: {}
      namespace: null
      namespaceSelector: null
      relabelings: []
      scheme: http
      scrapeTimeout: null
      tlsConfig: null
  metadata-cache:
    affinity: {}
    allocatedMemory: 512
    annotations: {}
    enabled: false
    extraArgs: {}
    extraContainers: []
    initContainers: []
    maxItemMemory: 1
    nodeSelector: {}
    podAnnotations: {}
    podDisruptionBudget: {}
    podLabels: {}
    podManagementPolicy: Parallel
    port: 11211
    priorityClassName: null
    replicas: 1
    resources: null
    service:
      annotations: {}
      labels: {}
    statefulStrategy:
      type: RollingUpdate
    terminationGracePeriodSeconds: 60
    tolerations: []
    topologySpreadConstraints: {}
  mimir:
    config: |
      usage_stats:
        installation_mode: helm
  
      activity_tracker:
        filepath: /active-query-tracker/activity.log
  
      {{- if .Values.enterprise.enabled }}
      admin_api:
        leader_election:
          enabled: true
          ring:
            kvstore:
              store: "memberlist"
  
      admin_client:
        storage:
        {{- if .Values.minio.enabled }}
          type: s3
          s3:
            access_key_id: {{ .Values.minio.rootUser }}
            bucket_name: enterprise-metrics-admin
            endpoint: {{ .Release.Name }}-minio.{{ .Release.Namespace }}.svc:9000
            insecure: true
            secret_access_key: {{ .Values.minio.rootPassword }}
        {{- end }}
        {{- if (index .Values "admin-cache" "enabled") }}
          cache:
            backend: memcached
            memcached:
              addresses: {{ include "mimir.adminCacheAddress" . }}
              max_item_size: {{ mul (index .Values "admin-cache").maxItemMemory 1024 1024 }}
        {{- end }}
      {{- end }}
  
      alertmanager:
        data_dir: /data
        enable_api: true
        external_url: /alertmanager
        {{- if .Values.alertmanager.zoneAwareReplication.enabled }}
        sharding_ring:
          zone_awareness_enabled: true
        {{- end }}
        {{- if .Values.alertmanager.fallbackConfig }}
        fallback_config_file: /configs/alertmanager_fallback_config.yaml
        {{- end }}
  
      {{- if .Values.minio.enabled }}
      alertmanager_storage:
        backend: s3
        s3:
          access_key_id: {{ .Values.minio.rootUser }}
          bucket_name: {{ include "mimir.minioBucketPrefix" . }}-ruler
          endpoint: {{ .Release.Name }}-minio.{{ .Release.Namespace }}.svc:9000
          insecure: true
          secret_access_key: {{ .Values.minio.rootPassword }}
      {{- end }}
  
      {{- if .Values.enterprise.enabled }}
      auth:
        type: enterprise
      {{- end }}
  
      # This configures how the store-gateway synchronizes blocks stored in the bucket. It uses Minio by default for getting started (configured via flags) but this should be changed for production deployments.
      blocks_storage:
        backend: s3
        bucket_store:
          max_chunk_pool_bytes: 12884901888 # 12GiB
          {{- if index .Values "chunks-cache" "enabled" }}
          chunks_cache:
            backend: memcached
            memcached:
              addresses: {{ include "mimir.chunksCacheAddress" . }}
              max_item_size: {{ mul (index .Values "chunks-cache").maxItemMemory 1024 1024 }}
              timeout: 450ms
          {{- end }}
          {{- if index .Values "index-cache" "enabled" }}
          index_cache:
            backend: memcached
            memcached:
              addresses: {{ include "mimir.indexCacheAddress" . }}
              max_item_size: {{ mul (index .Values "index-cache").maxItemMemory 1024 1024 }}
          {{- end }}
          {{- if index .Values "metadata-cache" "enabled" }}
          metadata_cache:
            backend: memcached
            memcached:
              addresses: {{ include "mimir.metadataCacheAddress" . }}
              max_item_size: {{ mul (index .Values "metadata-cache").maxItemMemory 1024 1024 }}
          {{- end }}
          sync_dir: /data/tsdb-sync
        {{- if .Values.minio.enabled }}
        s3:
          access_key_id: {{ .Values.minio.rootUser }}
          bucket_name: {{ include "mimir.minioBucketPrefix" . }}-tsdb
          endpoint: {{ .Release.Name }}-minio.{{ .Release.Namespace }}.svc:9000
          insecure: true
          secret_access_key: {{ .Values.minio.rootPassword }}
        {{- end }}
        tsdb:
          dir: /data/tsdb
  
      {{- if .Values.enterprise.enabled }}
      cluster_name: "{{ .Release.Name }}"
      {{- end }}
  
      compactor:
        compaction_interval: 30m
        deletion_delay: 2h
        max_closing_blocks_concurrency: 2
        max_opening_blocks_concurrency: 4
        symbols_flushers_concurrency: 4
        data_dir: "/data"
        sharding_ring:
          wait_stability_min_duration: 1m
  
      frontend:
        parallelize_shardable_queries: true
        {{- if index .Values "results-cache" "enabled" }}
        results_cache:
          backend: memcached
          memcached:
            timeout: 500ms
            addresses: {{ include "mimir.resultsCacheAddress" . }}
            max_item_size: {{ mul (index .Values "results-cache").maxItemMemory 1024 1024 }}
        cache_results: true
        {{- end }}
        {{- if .Values.query_scheduler.enabled }}
        scheduler_address: {{ template "mimir.fullname" . }}-query-scheduler-headless.{{ .Release.Namespace }}.svc:{{ include "mimir.serverGrpcListenPort" . }}
        {{- end }}
  
      frontend_worker:
        grpc_client_config:
          max_send_msg_size: 419430400 # 400MiB
        {{- if .Values.query_scheduler.enabled }}
        scheduler_address: {{ template "mimir.fullname" . }}-query-scheduler-headless.{{ .Release.Namespace }}.svc:{{ include "mimir.serverGrpcListenPort" . }}
        {{- else }}
        frontend_address: {{ template "mimir.fullname" . }}-query-frontend-headless.{{ .Release.Namespace }}.svc:{{ include "mimir.serverGrpcListenPort" . }}
        {{- end }}
  
      {{- if and .Values.enterprise.enabled }}
      gateway:
        proxy:
          admin_api:
            url: http://{{ template "mimir.fullname" . }}-admin-api.{{ .Release.Namespace }}.svc:{{ include "mimir.serverHttpListenPort" . }}
          alertmanager:
            url: http://{{ template "mimir.fullname" . }}-alertmanager-headless.{{ .Release.Namespace }}.svc:{{ include "mimir.serverHttpListenPort" . }}
          compactor:
            url: http://{{ template "mimir.fullname" . }}-compactor.{{ .Release.Namespace }}.svc:{{ include "mimir.serverHttpListenPort" . }}
          default:
            url: http://{{ template "mimir.fullname" . }}-admin-api.{{ .Release.Namespace }}.svc:{{ include "mimir.serverHttpListenPort" . }}
          distributor:
            url: dns:///{{ template "mimir.fullname" . }}-distributor-headless.{{ .Release.Namespace }}.svc.{{ .Values.global.clusterDomain }}:{{ include "mimir.serverGrpcListenPort" . }}
          ingester:
            url: http://{{ template "mimir.fullname" . }}-ingester-headless.{{ .Release.Namespace }}.svc:{{ include "mimir.serverHttpListenPort" . }}
          query_frontend:
            url: http://{{ template "mimir.fullname" . }}-query-frontend.{{ .Release.Namespace }}.svc:{{ include "mimir.serverHttpListenPort" . }}
          ruler:
            url: http://{{ template "mimir.fullname" . }}-ruler.{{ .Release.Namespace }}.svc:{{ include "mimir.serverHttpListenPort" . }}
          store_gateway:
            url: http://{{ template "mimir.fullname" . }}-store-gateway-headless.{{ .Release.Namespace }}.svc:{{ include "mimir.serverHttpListenPort" . }}
          {{- if and .Values.enterprise.enabled .Values.graphite.enabled }}
          graphite_write_proxy:
            url: http://{{ template "mimir.fullname" . }}-graphite-write-proxy.{{ .Release.Namespace }}.svc:{{ include "mimir.serverHttpListenPort" . }}
          graphite_querier:
            url: http://{{ template "mimir.fullname" . }}-graphite-querier.{{ .Release.Namespace }}.svc:{{ include "mimir.serverHttpListenPort" . }}
          {{- end}}
      {{- end }}
  
      ingester:
        ring:
          final_sleep: 0s
          num_tokens: 512
          tokens_file_path: /data/tokens
          unregister_on_shutdown: false
          {{- if .Values.ingester.zoneAwareReplication.enabled }}
          zone_awareness_enabled: true
          {{- end }}
  
      ingester_client:
        grpc_client_config:
          max_recv_msg_size: 104857600
          max_send_msg_size: 104857600
  
      {{- if .Values.enterprise.enabled }}
      instrumentation:
        enabled: true
        distributor_client:
          address: dns:///{{ template "mimir.fullname" . }}-distributor-headless.{{ .Release.Namespace }}.svc.{{ .Values.global.clusterDomain }}:{{ include "mimir.serverGrpcListenPort" . }}
  
      license:
        path: "/license/license.jwt"
      {{- end }}
  
      limits:
        # Limit queries to 500 days. You can override this on a per-tenant basis.
        max_total_query_length: 12000h
        # Adjust max query parallelism to 16x sharding, without sharding we can run 15d queries fully in parallel.
        # With sharding we can further shard each day another 16 times. 15 days * 16 shards = 240 subqueries.
        max_query_parallelism: 240
        # Avoid caching results newer than 10m because some samples can be delayed
        # This presents caching incomplete results
        max_cache_freshness: 10m
  
      memberlist:
        abort_if_cluster_join_fails: false
        compression_enabled: false
        join_members:
        - dns+{{ include "mimir.fullname" . }}-gossip-ring.{{ .Release.Namespace }}.svc.{{ .Values.global.clusterDomain }}:{{ include "mimir.memberlistBindPort" . }}
  
      querier:
        # With query sharding we run more but smaller queries. We must strike a balance
        # which allows us to process more sharded queries in parallel when requested, but not overload
        # queriers during non-sharded queries.
        max_concurrent: 16
  
      query_scheduler:
        # Increase from default of 100 to account for queries created by query sharding
        max_outstanding_requests_per_tenant: 800
  
      ruler:
        alertmanager_url: dnssrvnoa+http://_http-metrics._tcp.{{ template "mimir.fullname" . }}-alertmanager-headless.{{ .Release.Namespace }}.svc.{{ .Values.global.clusterDomain }}/alertmanager
        enable_api: true
        rule_path: /data
  
      {{- if .Values.minio.enabled }}
      ruler_storage:
        backend: s3
        s3:
          endpoint: {{ .Release.Name }}-minio.{{ .Release.Namespace }}.svc:9000
          bucket_name: {{ include "mimir.minioBucketPrefix" . }}-ruler
          access_key_id: {{ .Values.minio.rootUser }}
          secret_access_key: {{ .Values.minio.rootPassword }}
          insecure: true
      {{- end }}
  
      runtime_config:
        file: /var/{{ include "mimir.name" . }}/runtime.yaml
  
      server:
        grpc_server_max_concurrent_streams: 1000
        grpc_server_max_connection_age: 2m
        grpc_server_max_connection_age_grace: 5m
        grpc_server_max_connection_idle: 1m
  
      store_gateway:
        sharding_ring:
          wait_stability_min_duration: 1m
          {{- if .Values.store_gateway.zoneAwareReplication.enabled }}
          kvstore:
            prefix: multi-zone/
          {{- end }}
          tokens_file_path: /data/tokens
          {{- if .Values.store_gateway.zoneAwareReplication.enabled }}
          zone_awareness_enabled: true
          {{- end }}
  
      {{- if and .Values.enterprise.enabled .Values.graphite.enabled }}
      graphite:
        enabled: true
  
        write_proxy:
          distributor_client:
            address: dns:///{{ template "mimir.fullname" . }}-distributor.{{ .Release.Namespace }}.svc:{{ include "mimir.serverGrpcListenPort" .  }}
  
        querier:
          remote_read:
            query_address: http://{{ template "mimir.fullname" . }}-query-frontend.{{ .Release.Namespace }}.svc:{{ include "mimir.serverHttpListenPort" .  }}/prometheus
  
          graphite_fallback: http://{{ template "mimir.fullname" . }}-graphite-web.{{ .Release.Namespace}}.svc:{{ include "mimir.serverHttpListenPort" .  }}
  
          schemas:
            default_storage_schemas_file: /etc/graphite-proxy/storage-schemas.conf
            default_storage_aggregations_file: /etc/graphite-proxy/storage-aggregations.conf
          aggregation_cache:
            memcached:
              addresses: dnssrvnoa+{{ template "mimir.fullname" . }}-gr-aggr-cache.{{ .Release.Namespace}}.svc:11211
              timeout: 1s
          metric_name_cache:
            memcached:
              addresses: dnssrvnoa+{{ template "mimir.fullname" . }}-gr-metricname-cache.{{ .Release.Namespace}}.svc:11211
              timeout: 1s
      {{- end}}
    structuredConfig: {}
  minio:
    DeploymentUpdate:
      maxSurge: 100%
      maxUnavailable: 0
      type: RollingUpdate
    StatefulSetUpdate:
      updateStrategy: RollingUpdate
    additionalAnnotations: {}
    additionalLabels: {}
    affinity: {}
    bucketRoot: ""
    buckets:
    - name: mimir-tsdb
      policy: none
      purge: false
    - name: mimir-ruler
      policy: none
      purge: false
    - name: enterprise-metrics-tsdb
      policy: none
      purge: false
    - name: enterprise-metrics-admin
      policy: none
      purge: false
    - name: enterprise-metrics-ruler
      policy: none
      purge: false
    certsPath: /etc/minio/certs/
    clusterDomain: cluster.local
    configPathmc: /tmp/minio/mc/
    consoleIngress:
      annotations: {}
      enabled: false
      hosts:
      - console.minio-example.local
      labels: {}
      path: /
      tls: []
    consoleService:
      nodePort: 32001
      port: "9001"
      type: ClusterIP
    customCommandJob:
      exitCommand: ""
      resources:
        requests:
          memory: 128Mi
      securityContext:
        enabled: false
        fsGroup: 1000
        runAsGroup: 1000
        runAsUser: 1000
    customCommands: null
    drivesPerNode: 1
    enabled: true
    environment: null
    etcd:
      clientCert: ""
      clientCertKey: ""
      corednsPathPrefix: ""
      endpoints: []
      pathPrefix: ""
    existingSecret: ""
    extraArgs: []
    extraContainers: []
    extraVolumeMounts: []
    extraVolumes: []
    fullnameOverride: ""
    global:
      clusterDomain: cluster.local
      dnsNamespace: kube-system
      dnsService: kube-dns
      extraEnv: []
      extraEnvFrom: []
      podAnnotations: {}
    ignoreChartChecksums: false
    image:
      pullPolicy: IfNotPresent
      repository: quay.io/minio/minio
      tag: RELEASE.2022-12-12T19-27-27Z
    imagePullSecrets: []
    ingress:
      annotations: {}
      enabled: false
      hosts:
      - minio-example.local
      labels: {}
      path: /
      tls: []
    makeBucketJob:
      exitCommand: ""
      resources:
        requests:
          memory: 128Mi
      securityContext:
        enabled: false
        fsGroup: 1000
        runAsGroup: 1000
        runAsUser: 1000
    makePolicyJob:
      exitCommand: ""
      resources:
        requests:
          memory: 128Mi
      securityContext:
        enabled: false
        fsGroup: 1000
        runAsGroup: 1000
        runAsUser: 1000
    makeServiceAccountJob:
      exitCommand: ""
      resources:
        requests:
          memory: 128Mi
      securityContext:
        enabled: false
        fsGroup: 1000
        runAsGroup: 1000
        runAsUser: 1000
    makeUserJob:
      exitCommand: ""
      resources:
        requests:
          memory: 128Mi
      securityContext:
        enabled: false
        fsGroup: 1000
        runAsGroup: 1000
        runAsUser: 1000
    mcImage:
      pullPolicy: IfNotPresent
      repository: quay.io/minio/mc
      tag: RELEASE.2022-12-13T00-23-28Z
    metrics:
      serviceMonitor:
        additionalLabels: {}
        enabled: false
        includeNode: false
        public: true
        relabelConfigs: {}
        relabelConfigsCluster: {}
    minioAPIPort: "9000"
    minioConsolePort: "9001"
    mode: standalone
    mountPath: /export
    nameOverride: ""
    networkPolicy:
      allowExternal: true
      enabled: false
    nodeSelector: {}
    oidc:
      claimName: policy
      claimPrefix: ""
      clientId: minio
      clientSecret: ""
      comment: ""
      configUrl: https://identity-provider-url/.well-known/openid-configuration
      enabled: false
      redirectUri: https://console-endpoint-url/oauth_callback
      scopes: openid,profile,email
    persistence:
      VolumeName: ""
      accessMode: ReadWriteOnce
      annotations: {}
      enabled: true
      existingClaim: ""
      size: 5Gi
      storageClass: ""
      subPath: ""
    podAnnotations: {}
    podDisruptionBudget:
      enabled: false
      maxUnavailable: 1
    podLabels: {}
    policies: []
    pools: 1
    postJob:
      affinity: {}
      annotations: {}
      nodeSelector: {}
      podAnnotations: {}
      securityContext:
        enabled: false
        fsGroup: 1000
        runAsGroup: 1000
        runAsUser: 1000
      tolerations: []
    priorityClassName: ""
    replicas: 16
    resources:
      requests:
        cpu: 100m
        memory: 128Mi
    rootPassword: supersecret
    rootUser: grafana-mimir
    runtimeClassName: ""
    securityContext:
      enabled: true
      fsGroup: 1000
      fsGroupChangePolicy: OnRootMismatch
      runAsGroup: 1000
      runAsUser: 1000
    service:
      nodePort: 32000
      port: "9000"
      type: ClusterIP
    serviceAccount:
      create: true
      name: minio-sa
    tls:
      certSecret: ""
      enabled: false
      privateKey: private.key
      publicCrt: public.crt
    tolerations: []
    topologySpreadConstraints: []
    trustedCertsSecret: ""
    users:
    - accessKey: console
      policy: consoleAdmin
      secretKey: console123
  nameOverride: null
  nginx:
    affinity: ""
    annotations: {}
    autoscaling:
      enabled: false
      maxReplicas: 3
      minReplicas: 1
      targetCPUUtilizationPercentage: 60
      targetMemoryUtilizationPercentage: null
    basicAuth:
      enabled: false
      existingSecret: null
      htpasswd: '{{ htpasswd (required "''nginx.basicAuth.username'' is required" .Values.nginx.basicAuth.username)
        (required "''nginx.basicAuth.password'' is required" .Values.nginx.basicAuth.password)
        }}'
      password: null
      username: null
    containerSecurityContext:
      allowPrivilegeEscalation: false
      capabilities:
        drop:
        - ALL
      readOnlyRootFilesystem: true
    deploymentStrategy:
      type: RollingUpdate
    enabled: true
    extraArgs: {}
    extraContainers: []
    extraEnv: []
    extraEnvFrom: []
    extraVolumeMounts: []
    extraVolumes: []
    image:
      pullPolicy: IfNotPresent
      registry: docker.io
      repository: nginxinc/nginx-unprivileged
      tag: 1.22-alpine
    ingress:
      annotations: {}
      enabled: false
      hosts:
      - host: nginx.mimir.example.com
        paths:
        - path: /
      tls:
      - hosts:
        - nginx.mimir.example.com
        secretName: mimir-nginx-tls
    nginxConfig:
      accessLogEnabled: true
      errorLogLevel: error
      file: |
        worker_processes  5;  ## Default: 1
        error_log  /dev/stderr {{ .Values.nginx.nginxConfig.errorLogLevel }};
        pid        /tmp/nginx.pid;
        worker_rlimit_nofile 8192;
  
        events {
          worker_connections  4096;  ## Default: 1024
        }
  
        http {
          client_body_temp_path /tmp/client_temp;
          proxy_temp_path       /tmp/proxy_temp_path;
          fastcgi_temp_path     /tmp/fastcgi_temp;
          uwsgi_temp_path       /tmp/uwsgi_temp;
          scgi_temp_path        /tmp/scgi_temp;
  
          default_type application/octet-stream;
          log_format   {{ .Values.nginx.nginxConfig.logFormat }}
  
          {{- if .Values.nginx.verboseLogging }}
          access_log   /dev/stderr  main;
          {{- else }}
  
          map $status $loggable {
            ~^[23]  0;
            default 1;
          }
          access_log   {{ .Values.nginx.nginxConfig.accessLogEnabled | ternary "/dev/stderr  main  if=$loggable;" "off;" }}
          {{- end }}
  
          sendfile     on;
          tcp_nopush   on;
  
          {{- if .Values.nginx.nginxConfig.resolver }}
          resolver {{ .Values.nginx.nginxConfig.resolver }};
          {{- else }}
          resolver {{ .Values.global.dnsService }}.{{ .Values.global.dnsNamespace }}.svc.{{ .Values.global.clusterDomain }};
          {{- end }}
  
          {{- with .Values.nginx.nginxConfig.httpSnippet }}
          {{ . | nindent 2 }}
          {{- end }}
  
          # Ensure that X-Scope-OrgID is always present, default to the no_auth_tenant for backwards compatibility when multi-tenancy was turned off.
          map $http_x_scope_orgid $ensured_x_scope_orgid {
            default $http_x_scope_orgid;
            "" "{{ include "mimir.noAuthTenant" . }}";
          }
  
          server {
            listen 8080;
  
            {{- if .Values.nginx.basicAuth.enabled }}
            auth_basic           "Mimir";
            auth_basic_user_file /etc/nginx/secrets/.htpasswd;
            {{- end }}
  
            location = / {
              return 200 'OK';
              auth_basic off;
            }
  
            proxy_set_header X-Scope-OrgID $ensured_x_scope_orgid;
  
            # Distributor endpoints
            location /distributor {
              set $distributor {{ template "mimir.fullname" . }}-distributor-headless.{{ .Release.Namespace }}.svc.{{ .Values.global.clusterDomain }};
              proxy_pass      http://$distributor:{{ include "mimir.serverHttpListenPort" . }}$request_uri;
            }
            location = /api/v1/push {
              set $distributor {{ template "mimir.fullname" . }}-distributor-headless.{{ .Release.Namespace }}.svc.{{ .Values.global.clusterDomain }};
              proxy_pass      http://$distributor:{{ include "mimir.serverHttpListenPort" . }}$request_uri;
            }
            location /otlp/v1/metrics {
              set $distributor {{ template "mimir.fullname" . }}-distributor-headless.{{ .Release.Namespace }}.svc.{{ .Values.global.clusterDomain }};
              proxy_pass      http://$distributor:{{ include "mimir.serverHttpListenPort" . }}$request_uri;
            }
  
            # Alertmanager endpoints
            location {{ template "mimir.alertmanagerHttpPrefix" . }} {
              set $alertmanager {{ template "mimir.fullname" . }}-alertmanager-headless.{{ .Release.Namespace }}.svc.{{ .Values.global.clusterDomain }};
              proxy_pass      http://$alertmanager:{{ include "mimir.serverHttpListenPort" . }}$request_uri;
            }
            location = /multitenant_alertmanager/status {
              set $alertmanager {{ template "mimir.fullname" . }}-alertmanager-headless.{{ .Release.Namespace }}.svc.{{ .Values.global.clusterDomain }};
              proxy_pass      http://$alertmanager:{{ include "mimir.serverHttpListenPort" . }}$request_uri;
            }
            location = /api/v1/alerts {
              set $alertmanager {{ template "mimir.fullname" . }}-alertmanager-headless.{{ .Release.Namespace }}.svc.{{ .Values.global.clusterDomain }};
              proxy_pass      http://$alertmanager:{{ include "mimir.serverHttpListenPort" . }}$request_uri;
            }
  
            # Ruler endpoints
            location {{ template "mimir.prometheusHttpPrefix" . }}/config/v1/rules {
              set $ruler {{ template "mimir.fullname" . }}-ruler.{{ .Release.Namespace }}.svc.{{ .Values.global.clusterDomain }};
              proxy_pass      http://$ruler:{{ include "mimir.serverHttpListenPort" . }}$request_uri;
            }
            location {{ template "mimir.prometheusHttpPrefix" . }}/api/v1/rules {
              set $ruler {{ template "mimir.fullname" . }}-ruler.{{ .Release.Namespace }}.svc.{{ .Values.global.clusterDomain }};
              proxy_pass      http://$ruler:{{ include "mimir.serverHttpListenPort" . }}$request_uri;
            }
  
            location {{ template "mimir.prometheusHttpPrefix" . }}/api/v1/alerts {
              set $ruler {{ template "mimir.fullname" . }}-ruler.{{ .Release.Namespace }}.svc.{{ .Values.global.clusterDomain }};
              proxy_pass      http://$ruler:{{ include "mimir.serverHttpListenPort" . }}$request_uri;
            }
            location = /ruler/ring {
              set $ruler {{ template "mimir.fullname" . }}-ruler.{{ .Release.Namespace }}.svc.{{ .Values.global.clusterDomain }};
              proxy_pass      http://$ruler:{{ include "mimir.serverHttpListenPort" . }}$request_uri;
            }
  
            # Rest of {{ template "mimir.prometheusHttpPrefix" . }} goes to the query frontend
            location {{ template "mimir.prometheusHttpPrefix" . }} {
              set $query_frontend {{ template "mimir.fullname" . }}-query-frontend.{{ .Release.Namespace }}.svc.{{ .Values.global.clusterDomain }};
              proxy_pass      http://$query_frontend:{{ include "mimir.serverHttpListenPort" . }}$request_uri;
            }
  
            # Buildinfo endpoint can go to any component
            location = /api/v1/status/buildinfo {
              set $query_frontend {{ template "mimir.fullname" . }}-query-frontend.{{ .Release.Namespace }}.svc.{{ .Values.global.clusterDomain }};
              proxy_pass      http://$query_frontend:{{ include "mimir.serverHttpListenPort" . }}$request_uri;
            }
  
            # Compactor endpoint for uploading blocks
            location /api/v1/upload/block/ {
              set $compactor {{ template "mimir.fullname" . }}-compactor.{{ .Release.Namespace }}.svc.{{ .Values.global.clusterDomain }};
              proxy_pass      http://$compactor:{{ include "mimir.serverHttpListenPort" . }}$request_uri;
            }
  
            {{- with .Values.nginx.nginxConfig.serverSnippet }}
            {{ . | nindent 4 }}
            {{- end }}
          }
        }
      httpSnippet: ""
      logFormat: |-
        main '$remote_addr - $remote_user [$time_local]  $status '
                '"$request" $body_bytes_sent "$http_referer" '
                '"$http_user_agent" "$http_x_forwarded_for"';
      resolver: null
      serverSnippet: ""
    nodeSelector: {}
    podAnnotations: {}
    podDisruptionBudget: {}
    podLabels: {}
    podSecurityContext: {}
    priorityClassName: null
    readinessProbe:
      httpGet:
        path: /
        port: http-metric
      initialDelaySeconds: 15
      timeoutSeconds: 1
    replicas: 1
    resources: {}
    route:
      annotations: {}
      enabled: false
      host: nginx.mimir.example.com
      tls:
        termination: edge
    service:
      annotations: {}
      clusterIP: null
      labels: {}
      loadBalancerIP: null
      nodePort: null
      port: 80
      type: ClusterIP
    terminationGracePeriodSeconds: 30
    tolerations: []
    topologySpreadConstraints:
      maxSkew: 1
      topologyKey: kubernetes.io/hostname
      whenUnsatisfiable: ScheduleAnyway
    verboseLogging: true
  overrides_exporter:
    affinity: {}
    annotations: {}
    containerSecurityContext:
      allowPrivilegeEscalation: false
      capabilities:
        drop:
        - ALL
      readOnlyRootFilesystem: true
    enabled: true
    env: []
    extraArgs: {}
    extraContainers: []
    extraEnvFrom: []
    extraVolumeMounts: []
    extraVolumes: []
    initContainers: []
    livenessProbe:
      httpGet:
        path: /ready
        port: http-metrics
      initialDelaySeconds: 45
    nodeSelector: {}
    persistence:
      subPath: null
    podAnnotations: {}
    podDisruptionBudget: {}
    podLabels: {}
    priorityClassName: null
    readinessProbe:
      httpGet:
        path: /ready
        port: http-metrics
      initialDelaySeconds: 45
    replicas: 1
    resources:
      requests:
        cpu: 100m
        memory: 128Mi
    securityContext: {}
    service:
      annotations: {}
      labels: {}
    strategy:
      type: RollingUpdate
    terminationGracePeriodSeconds: 60
    tolerations: []
    topologySpreadConstraints: {}
  querier:
    affinity: {}
    annotations: {}
    containerSecurityContext:
      allowPrivilegeEscalation: false
      capabilities:
        drop:
        - ALL
      readOnlyRootFilesystem: true
    env: []
    extraArgs: {}
    extraContainers: []
    extraEnvFrom: []
    extraVolumeMounts: []
    extraVolumes: []
    initContainers: []
    nodeSelector: {}
    persistence:
      subPath: null
    podAnnotations: {}
    podDisruptionBudget: {}
    podLabels: {}
    priorityClassName: null
    readinessProbe:
      httpGet:
        path: /ready
        port: http-metrics
      initialDelaySeconds: 45
    replicas: 2
    resources:
      requests:
        cpu: 100m
        memory: 128Mi
    securityContext: {}
    service:
      annotations: {}
      labels: {}
    strategy:
      type: RollingUpdate
    terminationGracePeriodSeconds: 180
    tolerations: []
    topologySpreadConstraints:
      maxSkew: 1
      topologyKey: kubernetes.io/hostname
      whenUnsatisfiable: ScheduleAnyway
  query_frontend:
    affinity: {}
    annotations: {}
    containerSecurityContext:
      allowPrivilegeEscalation: false
      capabilities:
        drop:
        - ALL
      readOnlyRootFilesystem: true
    env: []
    extraArgs: {}
    extraContainers: []
    extraEnvFrom: []
    extraVolumeMounts: []
    extraVolumes: []
    initContainers: []
    nodeSelector: {}
    persistence:
      subPath: null
    podAnnotations: {}
    podDisruptionBudget: {}
    podLabels: {}
    priorityClassName: null
    readinessProbe:
      httpGet:
        path: /ready
        port: http-metrics
      initialDelaySeconds: 45
    replicas: 1
    resources:
      requests:
        cpu: 100m
        memory: 128Mi
    securityContext: {}
    service:
      annotations: {}
      labels: {}
    strategy:
      type: RollingUpdate
    terminationGracePeriodSeconds: 180
    tolerations: []
    topologySpreadConstraints:
      maxSkew: 1
      topologyKey: kubernetes.io/hostname
      whenUnsatisfiable: ScheduleAnyway
  query_scheduler:
    affinity: {}
    annotations: {}
    containerSecurityContext:
      allowPrivilegeEscalation: false
      capabilities:
        drop:
        - ALL
      readOnlyRootFilesystem: true
    enabled: true
    env: []
    extraArgs: {}
    extraContainers: []
    extraEnvFrom: []
    extraVolumeMounts: []
    extraVolumes: []
    initContainers: []
    nodeSelector: {}
    persistence:
      subPath: null
    podAnnotations: {}
    podDisruptionBudget: {}
    podLabels: {}
    priorityClassName: null
    readinessProbe:
      httpGet:
        path: /ready
        port: http-metrics
      initialDelaySeconds: 45
    replicas: 2
    resources:
      requests:
        cpu: 100m
        memory: 128Mi
    securityContext: {}
    service:
      annotations: {}
      labels: {}
    strategy:
      rollingUpdate:
        maxSurge: 0
        maxUnavailable: 1
      type: RollingUpdate
    terminationGracePeriodSeconds: 180
    tolerations: []
    topologySpreadConstraints:
      maxSkew: 1
      topologyKey: kubernetes.io/hostname
      whenUnsatisfiable: ScheduleAnyway
  rbac:
    create: true
    securityContext:
      fsGroup: 10001
      runAsGroup: 10001
      runAsNonRoot: true
      runAsUser: 10001
      seccompProfile:
        type: RuntimeDefault
    type: psp
  regoTestGenerateValues: "true"
  results-cache:
    affinity: {}
    allocatedMemory: 512
    annotations: {}
    enabled: false
    extraArgs: {}
    extraContainers: []
    initContainers: []
    maxItemMemory: 1
    nodeSelector: {}
    podAnnotations: {}
    podDisruptionBudget: {}
    podLabels: {}
    podManagementPolicy: Parallel
    port: 11211
    priorityClassName: null
    replicas: 1
    resources: null
    service:
      annotations: {}
      labels: {}
    statefulStrategy:
      type: RollingUpdate
    terminationGracePeriodSeconds: 60
    tolerations: []
    topologySpreadConstraints: {}
  rollout_operator:
    affinity: {}
    enabled: true
    fullnameOverride: ""
    global:
      clusterDomain: cluster.local
      dnsNamespace: kube-system
      dnsService: kube-dns
      extraEnv: []
      extraEnvFrom: []
      podAnnotations: {}
    image:
      pullPolicy: IfNotPresent
      repository: grafana/rollout-operator
      tag: ""
    imagePullSecrets: []
    minReadySeconds: 10
    nameOverride: ""
    nodeSelector: {}
    podAnnotations: {}
    podSecurityContext: {}
    resources:
      limits:
        cpu: "1"
        memory: 200Mi
      requests:
        cpu: 100m
        memory: 100Mi
    securityContext: {}
    serviceAccount:
      annotations: {}
      create: true
      name: ""
    serviceMonitor:
      annotations: {}
      enabled: false
      labels: {}
      namespaceSelector: {}
      relabelings: []
    tolerations: []
  ruler:
    affinity: {}
    annotations: {}
    containerSecurityContext:
      allowPrivilegeEscalation: false
      capabilities:
        drop:
        - ALL
      readOnlyRootFilesystem: true
    enabled: true
    env: []
    extraArgs: {}
    extraContainers: []
    extraEnvFrom: []
    extraVolumeMounts: []
    extraVolumes: []
    initContainers: []
    nodeSelector: {}
    persistence:
      subPath: null
    podAnnotations: {}
    podDisruptionBudget: {}
    podLabels: {}
    readinessProbe:
      httpGet:
        path: /ready
        port: http-metrics
      initialDelaySeconds: 45
    replicas: 1
    resources:
      requests:
        cpu: 100m
        memory: 128Mi
    securityContext: {}
    service:
      annotations: {}
      labels: {}
    strategy:
      rollingUpdate:
        maxSurge: 50%
        maxUnavailable: 0
      type: RollingUpdate
    terminationGracePeriodSeconds: 180
    tolerations: []
    topologySpreadConstraints:
      maxSkew: 1
      topologyKey: kubernetes.io/hostname
      whenUnsatisfiable: ScheduleAnyway
  runtimeConfig: {}
  serviceAccount:
    annotations: {}
    create: true
    name: null
  smoke_test:
    annotations: {}
    env: []
    extraArgs: {}
    extraEnvFrom: []
    image:
      pullPolicy: IfNotPresent
      repository: grafana/mimir-continuous-test
      tag: r228-651a8ed
    initContainers: []
    priorityClassName: null
    tenantId: ""
  store_gateway:
    affinity: {}
    annotations: {}
    containerSecurityContext:
      allowPrivilegeEscalation: false
      capabilities:
        drop:
        - ALL
      readOnlyRootFilesystem: true
    env: []
    extraArgs: {}
    extraContainers: []
    extraEnvFrom: []
    extraVolumeMounts: []
    extraVolumes: []
    initContainers: []
    nodeSelector: {}
    persistentVolume:
      accessModes:
      - ReadWriteOnce
      annotations: {}
      enabled: true
      size: 2Gi
      subPath: ""
    podAnnotations: {}
    podDisruptionBudget:
      maxUnavailable: 1
    podLabels: {}
    priorityClassName: null
    readinessProbe:
      httpGet:
        path: /ready
        port: http-metrics
      initialDelaySeconds: 60
    replicas: 1
    resources:
      requests:
        cpu: 100m
        memory: 512Mi
    schedulerName: ""
    securityContext: {}
    service:
      annotations: {}
      labels: {}
    strategy:
      type: RollingUpdate
    terminationGracePeriodSeconds: 240
    tolerations: []
    topologySpreadConstraints:
      maxSkew: 1
      topologyKey: kubernetes.io/hostname
      whenUnsatisfiable: ScheduleAnyway
    zoneAwareReplication:
      enabled: true
      maxUnavailable: 10
      migration:
        enabled: false
        readPath: false
      topologyKey: null
      zones:
      - extraAffinity: {}
        name: zone-a
        nodeSelector: null
      - extraAffinity: {}
        name: zone-b
        nodeSelector: null
      - extraAffinity: {}
        name: zone-c
        nodeSelector: null
  tokengenJob:
    annotations: {}
    containerSecurityContext:
      allowPrivilegeEscalation: false
      capabilities:
        drop:
        - ALL
      readOnlyRootFilesystem: true
    enable: true
    env: []
    extraArgs: {}
    extraEnvFrom: []
    initContainers: []
    priorityClassName: null
    securityContext: {}
  useExternalConfig: false
