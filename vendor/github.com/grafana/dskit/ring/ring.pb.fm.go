// GENERATED CODE - DO NOT EDIT
// This file was generated by protoc-gen-fastmarshal

package ring

import (
	"fmt"
	"sync/atomic"
	"github.com/CrowdStrike/csproto"
)

//------------------------------------------------------------------------------
// Custom Protobuf size/marshal/unmarshal code for Desc

// Size calculates and returns the size, in bytes, required to hold the contents of m using the Protobuf
// binary encoding.
func (m *Desc) Size() int {
	// nil message is always 0 bytes
	if m == nil {
		return 0
	}
	// return cached size, if present
	if csz := int(atomic.LoadInt32(&m.sizeCache)); csz > 0 {
		return csz
	}
	// calculate and cache
	var sz, l int
	_ = l // avoid unused variable

	// Ingesters (message,repeated)
	for k, v := range m.Ingesters {
		// size of key (always has an internal tag of 1)
		l = len(k)
		keySize := 1 + csproto.SizeOfVarint(uint64(l)) + l
		// size of value (always has an internal tag of 2)
		if v != nil {
			l = csproto.Size(v)
			valueSize := 1 + csproto.SizeOfVarint(uint64(l)) + l
			sz += csproto.SizeOfTagKey(1) + csproto.SizeOfVarint(uint64(keySize+valueSize)) + keySize + valueSize
		}
	}

	// cache the size so it can be re-used in Marshal()/MarshalTo()
	atomic.StoreInt32(&m.sizeCache, int32(sz))
	return sz
}

// Marshal converts the contents of m to the Protobuf binary encoding and returns the result or an error.
func (m *Desc) Marshal() ([]byte, error) {
	siz := m.Size()
	if siz == 0 {
		return []byte{}, nil
	}
	buf := make([]byte, siz)
	err := m.MarshalTo(buf)
	return buf, err
}

// MarshalTo converts the contents of m to the Protobuf binary encoding and writes the result to dest.
func (m *Desc) MarshalTo(dest []byte) error {
	// nil message == no-op
	if m == nil {
		return nil
	}
	var (
		enc    = csproto.NewEncoder(dest)
		buf    []byte
		err    error
		extVal interface{}
	)
	// ensure no unused variables
	_ = enc
	_ = buf
	_ = err
	_ = extVal

	// Ingesters (1,map)
	for k, v := range m.Ingesters {
		if v == nil {
			continue
		}
		valueSize := csproto.Size(v)
		itemSize := 1 + csproto.SizeOfVarint(uint64(valueSize)) + valueSize
		keySize := len(k)
		itemSize += 1 + csproto.SizeOfVarint(uint64(keySize)) + keySize
		enc.EncodeMapEntryHeader(1, itemSize)
		enc.EncodeString(1, k)
		enc.EncodeNested(2, v)
	}

	return nil
}

// Unmarshal decodes a binary encoded Protobuf message from p and populates m with the result.
func (m *Desc) Unmarshal(p []byte) error {
	m.Reset()
	if len(p) == 0 {
		return nil
	}
	dec := csproto.NewDecoder(p)
	for dec.More() {
		tag, wt, err := dec.DecodeTag()
		if err != nil {
			return err
		}
		switch tag {
		case 1: // Ingesters (map)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for map field 'ingesters' (tag=1), expected 2 (length-delimited)", wt)
			}

			if m.Ingesters == nil {
				m.Ingesters = make(map[string]*InstanceDesc)
			}
			// consume the map entry size
			// TODO - should we validate this?
			if _, err = dec.DecodeInt32(); err != nil {
				return err
			}
			// always 2 values
			var (
				entryKey   string
				entryValue *InstanceDesc
			)
			for i := 0; i < 2; i++ {
				etag, ewt, err := dec.DecodeTag()
				if err != nil {
					return err
				}
				switch etag {
				case 1: // key
					if ewt != csproto.WireTypeLengthDelimited {
						return fmt.Errorf("incorrect wire type %v for map key for field 'ingesters' (tag=1), expected 2 (length-delimited)", ewt)
					}
					if entryKey, err = dec.DecodeString(); err != nil {
						return err
					}
				case 2: // value
					if ewt != csproto.WireTypeLengthDelimited {
						return fmt.Errorf("incorrect wire type %v for map value for field 'ingesters' (tag=1), expected 2 (length-delimited)", ewt)
					}
					var v InstanceDesc
					if err = dec.DecodeNested(&v); err != nil {
						return err
					} else {
						entryValue = &v
					}
				default:
					return fmt.Errorf("invalid map entry field tag %d, expected 1 or 2", etag)
				}
			}
			m.Ingesters[entryKey] = entryValue

		default:
			if skipped, err := dec.Skip(tag, wt); err != nil {
				return fmt.Errorf("invalid operation skipping tag %v: %w", tag, err)
			} else {
				m.unknownFields = append(m.unknownFields, skipped...)
			}
		}
	}
	return nil
}

//------------------------------------------------------------------------------
// Custom Protobuf size/marshal/unmarshal code for InstanceDesc

// Size calculates and returns the size, in bytes, required to hold the contents of m using the Protobuf
// binary encoding.
func (m *InstanceDesc) Size() int {
	// nil message is always 0 bytes
	if m == nil {
		return 0
	}
	// return cached size, if present
	if csz := int(atomic.LoadInt32(&m.sizeCache)); csz > 0 {
		return csz
	}
	// calculate and cache
	var sz, l int
	_ = l // avoid unused variable

	// Addr (string,optional)
	if l = len(m.Addr); l > 0 {
		sz += csproto.SizeOfTagKey(1) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// Timestamp (int64,optional)
	if m.Timestamp != 0 {
		sz += csproto.SizeOfTagKey(2) + csproto.SizeOfVarint(uint64(m.Timestamp))
	}
	// State (enum,optional)
	if m.State != 0 {
		sz += csproto.SizeOfTagKey(3) + csproto.SizeOfVarint(uint64(m.State))
	}
	// Tokens (uint32,repeated,packed)
	if len(m.Tokens) > 0 {
		sz += csproto.SizeOfTagKey(6)
		l = 0
		for _, iv := range m.Tokens {
			l += csproto.SizeOfVarint(uint64(iv))
		}
		sz += csproto.SizeOfVarint(uint64(l)) + l
	}
	// Zone (string,optional)
	if l = len(m.Zone); l > 0 {
		sz += csproto.SizeOfTagKey(7) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// RegisteredTimestamp (int64,optional)
	if m.RegisteredTimestamp != 0 {
		sz += csproto.SizeOfTagKey(8) + csproto.SizeOfVarint(uint64(m.RegisteredTimestamp))
	}
	// Id (string,optional)
	if l = len(m.Id); l > 0 {
		sz += csproto.SizeOfTagKey(9) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// ReadOnlyUpdatedTimestamp (int64,optional)
	if m.ReadOnlyUpdatedTimestamp != 0 {
		sz += csproto.SizeOfTagKey(10) + csproto.SizeOfVarint(uint64(m.ReadOnlyUpdatedTimestamp))
	}
	// ReadOnly (bool,optional)
	if m.ReadOnly {
		sz += csproto.SizeOfTagKey(11) + 1
	}
	// cache the size so it can be re-used in Marshal()/MarshalTo()
	atomic.StoreInt32(&m.sizeCache, int32(sz))
	return sz
}

// Marshal converts the contents of m to the Protobuf binary encoding and returns the result or an error.
func (m *InstanceDesc) Marshal() ([]byte, error) {
	siz := m.Size()
	if siz == 0 {
		return []byte{}, nil
	}
	buf := make([]byte, siz)
	err := m.MarshalTo(buf)
	return buf, err
}

// MarshalTo converts the contents of m to the Protobuf binary encoding and writes the result to dest.
func (m *InstanceDesc) MarshalTo(dest []byte) error {
	// nil message == no-op
	if m == nil {
		return nil
	}
	var (
		enc    = csproto.NewEncoder(dest)
		buf    []byte
		err    error
		extVal interface{}
	)
	// ensure no unused variables
	_ = enc
	_ = buf
	_ = err
	_ = extVal

	// Addr (1,string,optional)
	if len(m.Addr) > 0 {
		enc.EncodeString(1, m.Addr)
	}
	// Timestamp (2,int64,optional)
	if m.Timestamp != 0 {
		enc.EncodeInt64(2, m.Timestamp)
	}
	// State (3,enum,optional)
	if m.State != 0 {
		enc.EncodeInt32(3, int32(m.State))
	}
	// Tokens (6,uint32,repeated,packed)
	if len(m.Tokens) > 0 {
		enc.EncodePackedUInt32(6, m.Tokens)
	}
	// Zone (7,string,optional)
	if len(m.Zone) > 0 {
		enc.EncodeString(7, m.Zone)
	}
	// RegisteredTimestamp (8,int64,optional)
	if m.RegisteredTimestamp != 0 {
		enc.EncodeInt64(8, m.RegisteredTimestamp)
	}
	// Id (9,string,optional)
	if len(m.Id) > 0 {
		enc.EncodeString(9, m.Id)
	}
	// ReadOnlyUpdatedTimestamp (10,int64,optional)
	if m.ReadOnlyUpdatedTimestamp != 0 {
		enc.EncodeInt64(10, m.ReadOnlyUpdatedTimestamp)
	}
	// ReadOnly (11,bool,optional)
	if m.ReadOnly {
		enc.EncodeBool(11, m.ReadOnly)
	}
	return nil
}

// Unmarshal decodes a binary encoded Protobuf message from p and populates m with the result.
func (m *InstanceDesc) Unmarshal(p []byte) error {
	m.Reset()
	if len(p) == 0 {
		return nil
	}
	dec := csproto.NewDecoder(p)
	for dec.More() {
		tag, wt, err := dec.DecodeTag()
		if err != nil {
			return err
		}
		switch tag {
		case 1: // Addr (string,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'addr' (tag=1), expected 2 (length-delimited)", wt)
			}
			if s, err := dec.DecodeString(); err != nil {
				return fmt.Errorf("unable to decode string value for field 'addr' (tag=1): %w", err)
			} else {
				m.Addr = s
			}

		case 2: // Timestamp (int64,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'timestamp' (tag=2), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt64(); err != nil {
				return fmt.Errorf("unable to decode int64 value for field 'timestamp' (tag=2): %w", err)
			} else {
				m.Timestamp = v
			}
		case 3: // State (enum,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'state' (tag=3), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt32(); err != nil {
				return fmt.Errorf("unable to decode int32 enum value for field 'state' (tag=3): %w", err)
			} else {
				m.State = InstanceState(v)
			}
		case 6: // Tokens (uint32,repeated,packed)
			switch wt {
			case csproto.WireTypeVarint:
				if v, err := dec.DecodeUInt32(); err != nil {
					return fmt.Errorf("unable to decode uint32 value for field 'tokens' (tag=6): %w", err)
				} else {
					m.Tokens = append(m.Tokens, v)
				}
			case csproto.WireTypeLengthDelimited:
				if v, err := dec.DecodePackedUint32(); err != nil {
					return fmt.Errorf("unable to decode packed uint32 values for field 'tokens' (tag=6): %w", err)
				} else {
					m.Tokens = append(m.Tokens, v...)
				}
			default:
				return fmt.Errorf("incorrect wire type %v for repeated field 'tokens' (tag=6), expected 0 (varint) or 1 (length-delimited)", wt)
			}
		case 7: // Zone (string,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'zone' (tag=7), expected 2 (length-delimited)", wt)
			}
			if s, err := dec.DecodeString(); err != nil {
				return fmt.Errorf("unable to decode string value for field 'zone' (tag=7): %w", err)
			} else {
				m.Zone = s
			}

		case 8: // RegisteredTimestamp (int64,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'registered_timestamp' (tag=8), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt64(); err != nil {
				return fmt.Errorf("unable to decode int64 value for field 'registered_timestamp' (tag=8): %w", err)
			} else {
				m.RegisteredTimestamp = v
			}
		case 9: // Id (string,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'id' (tag=9), expected 2 (length-delimited)", wt)
			}
			if s, err := dec.DecodeString(); err != nil {
				return fmt.Errorf("unable to decode string value for field 'id' (tag=9): %w", err)
			} else {
				m.Id = s
			}

		case 10: // ReadOnlyUpdatedTimestamp (int64,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'read_only_updated_timestamp' (tag=10), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt64(); err != nil {
				return fmt.Errorf("unable to decode int64 value for field 'read_only_updated_timestamp' (tag=10): %w", err)
			} else {
				m.ReadOnlyUpdatedTimestamp = v
			}
		case 11: // ReadOnly (bool,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'read_only' (tag=11), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeBool(); err != nil {
				return fmt.Errorf("unable to decode boolean value for field 'read_only' (tag=11): %w", err)
			} else {
				m.ReadOnly = v
			}

		default:
			if skipped, err := dec.Skip(tag, wt); err != nil {
				return fmt.Errorf("invalid operation skipping tag %v: %w", tag, err)
			} else {
				m.unknownFields = append(m.unknownFields, skipped...)
			}
		}
	}
	return nil
}
