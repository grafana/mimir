// GENERATED CODE - DO NOT EDIT
// This file was generated by protoc-gen-fastmarshal

package ring

import (
	"fmt"
	"sync/atomic"
	"github.com/CrowdStrike/csproto"
)

//------------------------------------------------------------------------------
// Custom Protobuf size/marshal/unmarshal code for PartitionRingDesc

// Size calculates and returns the size, in bytes, required to hold the contents of m using the Protobuf
// binary encoding.
func (m *PartitionRingDesc) Size() int {
	// nil message is always 0 bytes
	if m == nil {
		return 0
	}
	// return cached size, if present
	if csz := int(atomic.LoadInt32(&m.sizeCache)); csz > 0 {
		return csz
	}
	// calculate and cache
	var sz, l int
	_ = l // avoid unused variable

	// Partitions (message,repeated)
	for k, v := range m.Partitions {
		// size of key (always has an internal tag of 1)
		keySize := 1 + csproto.SizeOfVarint(uint64(k))
		// size of value (always has an internal tag of 2)
		if v != nil {
			l = csproto.Size(v)
			valueSize := 1 + csproto.SizeOfVarint(uint64(l)) + l
			sz += csproto.SizeOfTagKey(1) + csproto.SizeOfVarint(uint64(keySize+valueSize)) + keySize + valueSize
		}
	}

	// Owners (message,repeated)
	for k, v := range m.Owners {
		// size of key (always has an internal tag of 1)
		l = len(k)
		keySize := 1 + csproto.SizeOfVarint(uint64(l)) + l
		// size of value (always has an internal tag of 2)
		if v != nil {
			l = csproto.Size(v)
			valueSize := 1 + csproto.SizeOfVarint(uint64(l)) + l
			sz += csproto.SizeOfTagKey(2) + csproto.SizeOfVarint(uint64(keySize+valueSize)) + keySize + valueSize
		}
	}

	// cache the size so it can be re-used in Marshal()/MarshalTo()
	atomic.StoreInt32(&m.sizeCache, int32(sz))
	return sz
}

// Marshal converts the contents of m to the Protobuf binary encoding and returns the result or an error.
func (m *PartitionRingDesc) Marshal() ([]byte, error) {
	siz := m.Size()
	if siz == 0 {
		return []byte{}, nil
	}
	buf := make([]byte, siz)
	err := m.MarshalTo(buf)
	return buf, err
}

// MarshalTo converts the contents of m to the Protobuf binary encoding and writes the result to dest.
func (m *PartitionRingDesc) MarshalTo(dest []byte) error {
	// nil message == no-op
	if m == nil {
		return nil
	}
	var (
		enc    = csproto.NewEncoder(dest)
		buf    []byte
		err    error
		extVal interface{}
	)
	// ensure no unused variables
	_ = enc
	_ = buf
	_ = err
	_ = extVal

	// Partitions (1,map)
	for k, v := range m.Partitions {
		if v == nil {
			continue
		}
		valueSize := csproto.Size(v)
		itemSize := 1 + csproto.SizeOfVarint(uint64(valueSize)) + valueSize
		itemSize += 1 + csproto.SizeOfVarint(uint64(k))
		enc.EncodeMapEntryHeader(1, itemSize)
		enc.EncodeInt32(1, k)
		enc.EncodeNested(2, v)
	}

	// Owners (2,map)
	for k, v := range m.Owners {
		if v == nil {
			continue
		}
		valueSize := csproto.Size(v)
		itemSize := 1 + csproto.SizeOfVarint(uint64(valueSize)) + valueSize
		keySize := len(k)
		itemSize += 1 + csproto.SizeOfVarint(uint64(keySize)) + keySize
		enc.EncodeMapEntryHeader(2, itemSize)
		enc.EncodeString(1, k)
		enc.EncodeNested(2, v)
	}

	return nil
}

// Unmarshal decodes a binary encoded Protobuf message from p and populates m with the result.
func (m *PartitionRingDesc) Unmarshal(p []byte) error {
	m.Reset()
	if len(p) == 0 {
		return nil
	}
	dec := csproto.NewDecoder(p)
	for dec.More() {
		tag, wt, err := dec.DecodeTag()
		if err != nil {
			return err
		}
		switch tag {
		case 1: // Partitions (map)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for map field 'partitions' (tag=1), expected 2 (length-delimited)", wt)
			}

			if m.Partitions == nil {
				m.Partitions = make(map[int32]*PartitionDesc)
			}
			// consume the map entry size
			// TODO - should we validate this?
			if _, err = dec.DecodeInt32(); err != nil {
				return err
			}
			// always 2 values
			var (
				entryKey   int32
				entryValue *PartitionDesc
			)
			for i := 0; i < 2; i++ {
				etag, ewt, err := dec.DecodeTag()
				if err != nil {
					return err
				}
				switch etag {
				case 1: // key
					if ewt != csproto.WireTypeVarint {
						return fmt.Errorf("incorrect wire type %v for map key for field 'partitions' (tag=1), expected 0 (varint)", ewt)
					}
					if entryKey, err = dec.DecodeInt32(); err != nil {
						return err
					}
				case 2: // value
					if ewt != csproto.WireTypeLengthDelimited {
						return fmt.Errorf("incorrect wire type %v for map value for field 'partitions' (tag=1), expected 2 (length-delimited)", ewt)
					}
					var v PartitionDesc
					if err = dec.DecodeNested(&v); err != nil {
						return err
					} else {
						entryValue = &v
					}
				default:
					return fmt.Errorf("invalid map entry field tag %d, expected 1 or 2", etag)
				}
			}
			m.Partitions[entryKey] = entryValue
		case 2: // Owners (map)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for map field 'owners' (tag=2), expected 2 (length-delimited)", wt)
			}

			if m.Owners == nil {
				m.Owners = make(map[string]*OwnerDesc)
			}
			// consume the map entry size
			// TODO - should we validate this?
			if _, err = dec.DecodeInt32(); err != nil {
				return err
			}
			// always 2 values
			var (
				entryKey   string
				entryValue *OwnerDesc
			)
			for i := 0; i < 2; i++ {
				etag, ewt, err := dec.DecodeTag()
				if err != nil {
					return err
				}
				switch etag {
				case 1: // key
					if ewt != csproto.WireTypeLengthDelimited {
						return fmt.Errorf("incorrect wire type %v for map key for field 'owners' (tag=2), expected 2 (length-delimited)", ewt)
					}
					if entryKey, err = dec.DecodeString(); err != nil {
						return err
					}
				case 2: // value
					if ewt != csproto.WireTypeLengthDelimited {
						return fmt.Errorf("incorrect wire type %v for map value for field 'owners' (tag=2), expected 2 (length-delimited)", ewt)
					}
					var v OwnerDesc
					if err = dec.DecodeNested(&v); err != nil {
						return err
					} else {
						entryValue = &v
					}
				default:
					return fmt.Errorf("invalid map entry field tag %d, expected 1 or 2", etag)
				}
			}
			m.Owners[entryKey] = entryValue

		default:
			if skipped, err := dec.Skip(tag, wt); err != nil {
				return fmt.Errorf("invalid operation skipping tag %v: %w", tag, err)
			} else {
				m.unknownFields = append(m.unknownFields, skipped...)
			}
		}
	}
	return nil
}

//------------------------------------------------------------------------------
// Custom Protobuf size/marshal/unmarshal code for PartitionDesc

// Size calculates and returns the size, in bytes, required to hold the contents of m using the Protobuf
// binary encoding.
func (m *PartitionDesc) Size() int {
	// nil message is always 0 bytes
	if m == nil {
		return 0
	}
	// return cached size, if present
	if csz := int(atomic.LoadInt32(&m.sizeCache)); csz > 0 {
		return csz
	}
	// calculate and cache
	var sz, l int
	_ = l // avoid unused variable

	// Id (int32,optional)
	if m.Id != 0 {
		sz += csproto.SizeOfTagKey(4) + csproto.SizeOfVarint(uint64(m.Id))
	}
	// Tokens (uint32,repeated,packed)
	if len(m.Tokens) > 0 {
		sz += csproto.SizeOfTagKey(1)
		l = 0
		for _, iv := range m.Tokens {
			l += csproto.SizeOfVarint(uint64(iv))
		}
		sz += csproto.SizeOfVarint(uint64(l)) + l
	}
	// State (enum,optional)
	if m.State != 0 {
		sz += csproto.SizeOfTagKey(2) + csproto.SizeOfVarint(uint64(m.State))
	}
	// StateTimestamp (int64,optional)
	if m.StateTimestamp != 0 {
		sz += csproto.SizeOfTagKey(3) + csproto.SizeOfVarint(uint64(m.StateTimestamp))
	}
	// cache the size so it can be re-used in Marshal()/MarshalTo()
	atomic.StoreInt32(&m.sizeCache, int32(sz))
	return sz
}

// Marshal converts the contents of m to the Protobuf binary encoding and returns the result or an error.
func (m *PartitionDesc) Marshal() ([]byte, error) {
	siz := m.Size()
	if siz == 0 {
		return []byte{}, nil
	}
	buf := make([]byte, siz)
	err := m.MarshalTo(buf)
	return buf, err
}

// MarshalTo converts the contents of m to the Protobuf binary encoding and writes the result to dest.
func (m *PartitionDesc) MarshalTo(dest []byte) error {
	// nil message == no-op
	if m == nil {
		return nil
	}
	var (
		enc    = csproto.NewEncoder(dest)
		buf    []byte
		err    error
		extVal interface{}
	)
	// ensure no unused variables
	_ = enc
	_ = buf
	_ = err
	_ = extVal

	// Id (4,int32,optional)
	if m.Id != 0 {
		enc.EncodeInt32(4, m.Id)
	}
	// Tokens (1,uint32,repeated,packed)
	if len(m.Tokens) > 0 {
		enc.EncodePackedUInt32(1, m.Tokens)
	}
	// State (2,enum,optional)
	if m.State != 0 {
		enc.EncodeInt32(2, int32(m.State))
	}
	// StateTimestamp (3,int64,optional)
	if m.StateTimestamp != 0 {
		enc.EncodeInt64(3, m.StateTimestamp)
	}
	return nil
}

// Unmarshal decodes a binary encoded Protobuf message from p and populates m with the result.
func (m *PartitionDesc) Unmarshal(p []byte) error {
	m.Reset()
	if len(p) == 0 {
		return nil
	}
	dec := csproto.NewDecoder(p)
	for dec.More() {
		tag, wt, err := dec.DecodeTag()
		if err != nil {
			return err
		}
		switch tag {
		case 4: // Id (int32,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'id' (tag=4), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt32(); err != nil {
				return fmt.Errorf("unable to decode int32 value for field 'id' (tag=4): %w", err)
			} else {
				m.Id = v
			}
		case 1: // Tokens (uint32,repeated,packed)
			switch wt {
			case csproto.WireTypeVarint:
				if v, err := dec.DecodeUInt32(); err != nil {
					return fmt.Errorf("unable to decode uint32 value for field 'tokens' (tag=1): %w", err)
				} else {
					m.Tokens = append(m.Tokens, v)
				}
			case csproto.WireTypeLengthDelimited:
				if v, err := dec.DecodePackedUint32(); err != nil {
					return fmt.Errorf("unable to decode packed uint32 values for field 'tokens' (tag=1): %w", err)
				} else {
					m.Tokens = append(m.Tokens, v...)
				}
			default:
				return fmt.Errorf("incorrect wire type %v for repeated field 'tokens' (tag=1), expected 0 (varint) or 1 (length-delimited)", wt)
			}
		case 2: // State (enum,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'state' (tag=2), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt32(); err != nil {
				return fmt.Errorf("unable to decode int32 enum value for field 'state' (tag=2): %w", err)
			} else {
				m.State = PartitionState(v)
			}
		case 3: // StateTimestamp (int64,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'stateTimestamp' (tag=3), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt64(); err != nil {
				return fmt.Errorf("unable to decode int64 value for field 'stateTimestamp' (tag=3): %w", err)
			} else {
				m.StateTimestamp = v
			}

		default:
			if skipped, err := dec.Skip(tag, wt); err != nil {
				return fmt.Errorf("invalid operation skipping tag %v: %w", tag, err)
			} else {
				m.unknownFields = append(m.unknownFields, skipped...)
			}
		}
	}
	return nil
}

//------------------------------------------------------------------------------
// Custom Protobuf size/marshal/unmarshal code for OwnerDesc

// Size calculates and returns the size, in bytes, required to hold the contents of m using the Protobuf
// binary encoding.
func (m *OwnerDesc) Size() int {
	// nil message is always 0 bytes
	if m == nil {
		return 0
	}
	// return cached size, if present
	if csz := int(atomic.LoadInt32(&m.sizeCache)); csz > 0 {
		return csz
	}
	// calculate and cache
	var sz, l int
	_ = l // avoid unused variable

	// OwnedPartition (int32,optional)
	if m.OwnedPartition != 0 {
		sz += csproto.SizeOfTagKey(1) + csproto.SizeOfVarint(uint64(m.OwnedPartition))
	}
	// State (enum,optional)
	if m.State != 0 {
		sz += csproto.SizeOfTagKey(2) + csproto.SizeOfVarint(uint64(m.State))
	}
	// UpdatedTimestamp (int64,optional)
	if m.UpdatedTimestamp != 0 {
		sz += csproto.SizeOfTagKey(3) + csproto.SizeOfVarint(uint64(m.UpdatedTimestamp))
	}
	// cache the size so it can be re-used in Marshal()/MarshalTo()
	atomic.StoreInt32(&m.sizeCache, int32(sz))
	return sz
}

// Marshal converts the contents of m to the Protobuf binary encoding and returns the result or an error.
func (m *OwnerDesc) Marshal() ([]byte, error) {
	siz := m.Size()
	if siz == 0 {
		return []byte{}, nil
	}
	buf := make([]byte, siz)
	err := m.MarshalTo(buf)
	return buf, err
}

// MarshalTo converts the contents of m to the Protobuf binary encoding and writes the result to dest.
func (m *OwnerDesc) MarshalTo(dest []byte) error {
	// nil message == no-op
	if m == nil {
		return nil
	}
	var (
		enc    = csproto.NewEncoder(dest)
		buf    []byte
		err    error
		extVal interface{}
	)
	// ensure no unused variables
	_ = enc
	_ = buf
	_ = err
	_ = extVal

	// OwnedPartition (1,int32,optional)
	if m.OwnedPartition != 0 {
		enc.EncodeInt32(1, m.OwnedPartition)
	}
	// State (2,enum,optional)
	if m.State != 0 {
		enc.EncodeInt32(2, int32(m.State))
	}
	// UpdatedTimestamp (3,int64,optional)
	if m.UpdatedTimestamp != 0 {
		enc.EncodeInt64(3, m.UpdatedTimestamp)
	}
	return nil
}

// Unmarshal decodes a binary encoded Protobuf message from p and populates m with the result.
func (m *OwnerDesc) Unmarshal(p []byte) error {
	m.Reset()
	if len(p) == 0 {
		return nil
	}
	dec := csproto.NewDecoder(p)
	for dec.More() {
		tag, wt, err := dec.DecodeTag()
		if err != nil {
			return err
		}
		switch tag {
		case 1: // OwnedPartition (int32,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'ownedPartition' (tag=1), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt32(); err != nil {
				return fmt.Errorf("unable to decode int32 value for field 'ownedPartition' (tag=1): %w", err)
			} else {
				m.OwnedPartition = v
			}
		case 2: // State (enum,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'state' (tag=2), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt32(); err != nil {
				return fmt.Errorf("unable to decode int32 enum value for field 'state' (tag=2): %w", err)
			} else {
				m.State = OwnerState(v)
			}
		case 3: // UpdatedTimestamp (int64,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'updatedTimestamp' (tag=3), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt64(); err != nil {
				return fmt.Errorf("unable to decode int64 value for field 'updatedTimestamp' (tag=3): %w", err)
			} else {
				m.UpdatedTimestamp = v
			}

		default:
			if skipped, err := dec.Skip(tag, wt); err != nil {
				return fmt.Errorf("invalid operation skipping tag %v: %w", tag, err)
			} else {
				m.unknownFields = append(m.unknownFields, skipped...)
			}
		}
	}
	return nil
}
