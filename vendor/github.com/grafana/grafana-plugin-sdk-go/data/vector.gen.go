// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package data

import (
	"encoding/json"
	"time"
)

type uint8Vector []uint8

func newUint8Vector(n int) *uint8Vector {
	v := uint8Vector(make([]uint8, n))
	return &v
}

func newUint8VectorWithValues(s []uint8) *uint8Vector {
	v := make([]uint8, len(s))
	copy(v, s)
	return (*uint8Vector)(&v)
}

func (v *uint8Vector) Set(idx int, i interface{}) {
	(*v)[idx] = i.(uint8)
}

func (v *uint8Vector) SetConcrete(idx int, i interface{}) {
	v.Set(idx, i)
}

func (v *uint8Vector) Append(i interface{}) {
	*v = append(*v, i.(uint8))
}

func (v *uint8Vector) At(i int) interface{} {
	return (*v)[i]
}

func (v *uint8Vector) PointerAt(i int) interface{} {
	return &(*v)[i]
}

func (v *uint8Vector) Len() int {
	return len(*v)
}

func (v *uint8Vector) CopyAt(i int) interface{} {
	var g uint8
	g = (*v)[i]
	return g
}

func (v *uint8Vector) ConcreteAt(i int) (interface{}, bool) {
	return v.At(i), true
}

func (v *uint8Vector) Type() FieldType {
	return vectorFieldType(v)
}

func (v *uint8Vector) Extend(i int) {
	*v = append(*v, make([]uint8, i)...)
}

func (v *uint8Vector) Insert(i int, val interface{}) {
	switch {
	case i < v.Len():
		v.Extend(1)
		copy((*v)[i+1:], (*v)[i:])
		v.Set(i, val)
	case i == v.Len():
		v.Append(val)
	case i > v.Len():
		panic("Invalid index; vector length should be greater or equal to that index")
	}
}

func (v *uint8Vector) Delete(i int) {
	*v = append((*v)[:i], (*v)[i+1:]...)
}

type uint16Vector []uint16

func newUint16Vector(n int) *uint16Vector {
	v := uint16Vector(make([]uint16, n))
	return &v
}

func newUint16VectorWithValues(s []uint16) *uint16Vector {
	v := make([]uint16, len(s))
	copy(v, s)
	return (*uint16Vector)(&v)
}

func (v *uint16Vector) Set(idx int, i interface{}) {
	(*v)[idx] = i.(uint16)
}

func (v *uint16Vector) SetConcrete(idx int, i interface{}) {
	v.Set(idx, i)
}

func (v *uint16Vector) Append(i interface{}) {
	*v = append(*v, i.(uint16))
}

func (v *uint16Vector) At(i int) interface{} {
	return (*v)[i]
}

func (v *uint16Vector) PointerAt(i int) interface{} {
	return &(*v)[i]
}

func (v *uint16Vector) Len() int {
	return len(*v)
}

func (v *uint16Vector) CopyAt(i int) interface{} {
	var g uint16
	g = (*v)[i]
	return g
}

func (v *uint16Vector) ConcreteAt(i int) (interface{}, bool) {
	return v.At(i), true
}

func (v *uint16Vector) Type() FieldType {
	return vectorFieldType(v)
}

func (v *uint16Vector) Extend(i int) {
	*v = append(*v, make([]uint16, i)...)
}

func (v *uint16Vector) Insert(i int, val interface{}) {
	switch {
	case i < v.Len():
		v.Extend(1)
		copy((*v)[i+1:], (*v)[i:])
		v.Set(i, val)
	case i == v.Len():
		v.Append(val)
	case i > v.Len():
		panic("Invalid index; vector length should be greater or equal to that index")
	}
}

func (v *uint16Vector) Delete(i int) {
	*v = append((*v)[:i], (*v)[i+1:]...)
}

type uint32Vector []uint32

func newUint32Vector(n int) *uint32Vector {
	v := uint32Vector(make([]uint32, n))
	return &v
}

func newUint32VectorWithValues(s []uint32) *uint32Vector {
	v := make([]uint32, len(s))
	copy(v, s)
	return (*uint32Vector)(&v)
}

func (v *uint32Vector) Set(idx int, i interface{}) {
	(*v)[idx] = i.(uint32)
}

func (v *uint32Vector) SetConcrete(idx int, i interface{}) {
	v.Set(idx, i)
}

func (v *uint32Vector) Append(i interface{}) {
	*v = append(*v, i.(uint32))
}

func (v *uint32Vector) At(i int) interface{} {
	return (*v)[i]
}

func (v *uint32Vector) PointerAt(i int) interface{} {
	return &(*v)[i]
}

func (v *uint32Vector) Len() int {
	return len(*v)
}

func (v *uint32Vector) CopyAt(i int) interface{} {
	var g uint32
	g = (*v)[i]
	return g
}

func (v *uint32Vector) ConcreteAt(i int) (interface{}, bool) {
	return v.At(i), true
}

func (v *uint32Vector) Type() FieldType {
	return vectorFieldType(v)
}

func (v *uint32Vector) Extend(i int) {
	*v = append(*v, make([]uint32, i)...)
}

func (v *uint32Vector) Insert(i int, val interface{}) {
	switch {
	case i < v.Len():
		v.Extend(1)
		copy((*v)[i+1:], (*v)[i:])
		v.Set(i, val)
	case i == v.Len():
		v.Append(val)
	case i > v.Len():
		panic("Invalid index; vector length should be greater or equal to that index")
	}
}

func (v *uint32Vector) Delete(i int) {
	*v = append((*v)[:i], (*v)[i+1:]...)
}

type uint64Vector []uint64

func newUint64Vector(n int) *uint64Vector {
	v := uint64Vector(make([]uint64, n))
	return &v
}

func newUint64VectorWithValues(s []uint64) *uint64Vector {
	v := make([]uint64, len(s))
	copy(v, s)
	return (*uint64Vector)(&v)
}

func (v *uint64Vector) Set(idx int, i interface{}) {
	(*v)[idx] = i.(uint64)
}

func (v *uint64Vector) SetConcrete(idx int, i interface{}) {
	v.Set(idx, i)
}

func (v *uint64Vector) Append(i interface{}) {
	*v = append(*v, i.(uint64))
}

func (v *uint64Vector) At(i int) interface{} {
	return (*v)[i]
}

func (v *uint64Vector) PointerAt(i int) interface{} {
	return &(*v)[i]
}

func (v *uint64Vector) Len() int {
	return len(*v)
}

func (v *uint64Vector) CopyAt(i int) interface{} {
	var g uint64
	g = (*v)[i]
	return g
}

func (v *uint64Vector) ConcreteAt(i int) (interface{}, bool) {
	return v.At(i), true
}

func (v *uint64Vector) Type() FieldType {
	return vectorFieldType(v)
}

func (v *uint64Vector) Extend(i int) {
	*v = append(*v, make([]uint64, i)...)
}

func (v *uint64Vector) Insert(i int, val interface{}) {
	switch {
	case i < v.Len():
		v.Extend(1)
		copy((*v)[i+1:], (*v)[i:])
		v.Set(i, val)
	case i == v.Len():
		v.Append(val)
	case i > v.Len():
		panic("Invalid index; vector length should be greater or equal to that index")
	}
}

func (v *uint64Vector) Delete(i int) {
	*v = append((*v)[:i], (*v)[i+1:]...)
}

type int8Vector []int8

func newInt8Vector(n int) *int8Vector {
	v := int8Vector(make([]int8, n))
	return &v
}

func newInt8VectorWithValues(s []int8) *int8Vector {
	v := make([]int8, len(s))
	copy(v, s)
	return (*int8Vector)(&v)
}

func (v *int8Vector) Set(idx int, i interface{}) {
	(*v)[idx] = i.(int8)
}

func (v *int8Vector) SetConcrete(idx int, i interface{}) {
	v.Set(idx, i)
}

func (v *int8Vector) Append(i interface{}) {
	*v = append(*v, i.(int8))
}

func (v *int8Vector) At(i int) interface{} {
	return (*v)[i]
}

func (v *int8Vector) PointerAt(i int) interface{} {
	return &(*v)[i]
}

func (v *int8Vector) Len() int {
	return len(*v)
}

func (v *int8Vector) CopyAt(i int) interface{} {
	var g int8
	g = (*v)[i]
	return g
}

func (v *int8Vector) ConcreteAt(i int) (interface{}, bool) {
	return v.At(i), true
}

func (v *int8Vector) Type() FieldType {
	return vectorFieldType(v)
}

func (v *int8Vector) Extend(i int) {
	*v = append(*v, make([]int8, i)...)
}

func (v *int8Vector) Insert(i int, val interface{}) {
	switch {
	case i < v.Len():
		v.Extend(1)
		copy((*v)[i+1:], (*v)[i:])
		v.Set(i, val)
	case i == v.Len():
		v.Append(val)
	case i > v.Len():
		panic("Invalid index; vector length should be greater or equal to that index")
	}
}

func (v *int8Vector) Delete(i int) {
	*v = append((*v)[:i], (*v)[i+1:]...)
}

type int16Vector []int16

func newInt16Vector(n int) *int16Vector {
	v := int16Vector(make([]int16, n))
	return &v
}

func newInt16VectorWithValues(s []int16) *int16Vector {
	v := make([]int16, len(s))
	copy(v, s)
	return (*int16Vector)(&v)
}

func (v *int16Vector) Set(idx int, i interface{}) {
	(*v)[idx] = i.(int16)
}

func (v *int16Vector) SetConcrete(idx int, i interface{}) {
	v.Set(idx, i)
}

func (v *int16Vector) Append(i interface{}) {
	*v = append(*v, i.(int16))
}

func (v *int16Vector) At(i int) interface{} {
	return (*v)[i]
}

func (v *int16Vector) PointerAt(i int) interface{} {
	return &(*v)[i]
}

func (v *int16Vector) Len() int {
	return len(*v)
}

func (v *int16Vector) CopyAt(i int) interface{} {
	var g int16
	g = (*v)[i]
	return g
}

func (v *int16Vector) ConcreteAt(i int) (interface{}, bool) {
	return v.At(i), true
}

func (v *int16Vector) Type() FieldType {
	return vectorFieldType(v)
}

func (v *int16Vector) Extend(i int) {
	*v = append(*v, make([]int16, i)...)
}

func (v *int16Vector) Insert(i int, val interface{}) {
	switch {
	case i < v.Len():
		v.Extend(1)
		copy((*v)[i+1:], (*v)[i:])
		v.Set(i, val)
	case i == v.Len():
		v.Append(val)
	case i > v.Len():
		panic("Invalid index; vector length should be greater or equal to that index")
	}
}

func (v *int16Vector) Delete(i int) {
	*v = append((*v)[:i], (*v)[i+1:]...)
}

type int32Vector []int32

func newInt32Vector(n int) *int32Vector {
	v := int32Vector(make([]int32, n))
	return &v
}

func newInt32VectorWithValues(s []int32) *int32Vector {
	v := make([]int32, len(s))
	copy(v, s)
	return (*int32Vector)(&v)
}

func (v *int32Vector) Set(idx int, i interface{}) {
	(*v)[idx] = i.(int32)
}

func (v *int32Vector) SetConcrete(idx int, i interface{}) {
	v.Set(idx, i)
}

func (v *int32Vector) Append(i interface{}) {
	*v = append(*v, i.(int32))
}

func (v *int32Vector) At(i int) interface{} {
	return (*v)[i]
}

func (v *int32Vector) PointerAt(i int) interface{} {
	return &(*v)[i]
}

func (v *int32Vector) Len() int {
	return len(*v)
}

func (v *int32Vector) CopyAt(i int) interface{} {
	var g int32
	g = (*v)[i]
	return g
}

func (v *int32Vector) ConcreteAt(i int) (interface{}, bool) {
	return v.At(i), true
}

func (v *int32Vector) Type() FieldType {
	return vectorFieldType(v)
}

func (v *int32Vector) Extend(i int) {
	*v = append(*v, make([]int32, i)...)
}

func (v *int32Vector) Insert(i int, val interface{}) {
	switch {
	case i < v.Len():
		v.Extend(1)
		copy((*v)[i+1:], (*v)[i:])
		v.Set(i, val)
	case i == v.Len():
		v.Append(val)
	case i > v.Len():
		panic("Invalid index; vector length should be greater or equal to that index")
	}
}

func (v *int32Vector) Delete(i int) {
	*v = append((*v)[:i], (*v)[i+1:]...)
}

type int64Vector []int64

func newInt64Vector(n int) *int64Vector {
	v := int64Vector(make([]int64, n))
	return &v
}

func newInt64VectorWithValues(s []int64) *int64Vector {
	v := make([]int64, len(s))
	copy(v, s)
	return (*int64Vector)(&v)
}

func (v *int64Vector) Set(idx int, i interface{}) {
	(*v)[idx] = i.(int64)
}

func (v *int64Vector) SetConcrete(idx int, i interface{}) {
	v.Set(idx, i)
}

func (v *int64Vector) Append(i interface{}) {
	*v = append(*v, i.(int64))
}

func (v *int64Vector) At(i int) interface{} {
	return (*v)[i]
}

func (v *int64Vector) PointerAt(i int) interface{} {
	return &(*v)[i]
}

func (v *int64Vector) Len() int {
	return len(*v)
}

func (v *int64Vector) CopyAt(i int) interface{} {
	var g int64
	g = (*v)[i]
	return g
}

func (v *int64Vector) ConcreteAt(i int) (interface{}, bool) {
	return v.At(i), true
}

func (v *int64Vector) Type() FieldType {
	return vectorFieldType(v)
}

func (v *int64Vector) Extend(i int) {
	*v = append(*v, make([]int64, i)...)
}

func (v *int64Vector) Insert(i int, val interface{}) {
	switch {
	case i < v.Len():
		v.Extend(1)
		copy((*v)[i+1:], (*v)[i:])
		v.Set(i, val)
	case i == v.Len():
		v.Append(val)
	case i > v.Len():
		panic("Invalid index; vector length should be greater or equal to that index")
	}
}

func (v *int64Vector) Delete(i int) {
	*v = append((*v)[:i], (*v)[i+1:]...)
}

type float32Vector []float32

func newFloat32Vector(n int) *float32Vector {
	v := float32Vector(make([]float32, n))
	return &v
}

func newFloat32VectorWithValues(s []float32) *float32Vector {
	v := make([]float32, len(s))
	copy(v, s)
	return (*float32Vector)(&v)
}

func (v *float32Vector) Set(idx int, i interface{}) {
	(*v)[idx] = i.(float32)
}

func (v *float32Vector) SetConcrete(idx int, i interface{}) {
	v.Set(idx, i)
}

func (v *float32Vector) Append(i interface{}) {
	*v = append(*v, i.(float32))
}

func (v *float32Vector) At(i int) interface{} {
	return (*v)[i]
}

func (v *float32Vector) PointerAt(i int) interface{} {
	return &(*v)[i]
}

func (v *float32Vector) Len() int {
	return len(*v)
}

func (v *float32Vector) CopyAt(i int) interface{} {
	var g float32
	g = (*v)[i]
	return g
}

func (v *float32Vector) ConcreteAt(i int) (interface{}, bool) {
	return v.At(i), true
}

func (v *float32Vector) Type() FieldType {
	return vectorFieldType(v)
}

func (v *float32Vector) Extend(i int) {
	*v = append(*v, make([]float32, i)...)
}

func (v *float32Vector) Insert(i int, val interface{}) {
	switch {
	case i < v.Len():
		v.Extend(1)
		copy((*v)[i+1:], (*v)[i:])
		v.Set(i, val)
	case i == v.Len():
		v.Append(val)
	case i > v.Len():
		panic("Invalid index; vector length should be greater or equal to that index")
	}
}

func (v *float32Vector) Delete(i int) {
	*v = append((*v)[:i], (*v)[i+1:]...)
}

type float64Vector []float64

func newFloat64Vector(n int) *float64Vector {
	v := float64Vector(make([]float64, n))
	return &v
}

func newFloat64VectorWithValues(s []float64) *float64Vector {
	v := make([]float64, len(s))
	copy(v, s)
	return (*float64Vector)(&v)
}

func (v *float64Vector) Set(idx int, i interface{}) {
	(*v)[idx] = i.(float64)
}

func (v *float64Vector) SetConcrete(idx int, i interface{}) {
	v.Set(idx, i)
}

func (v *float64Vector) Append(i interface{}) {
	*v = append(*v, i.(float64))
}

func (v *float64Vector) At(i int) interface{} {
	return (*v)[i]
}

func (v *float64Vector) PointerAt(i int) interface{} {
	return &(*v)[i]
}

func (v *float64Vector) Len() int {
	return len(*v)
}

func (v *float64Vector) CopyAt(i int) interface{} {
	var g float64
	g = (*v)[i]
	return g
}

func (v *float64Vector) ConcreteAt(i int) (interface{}, bool) {
	return v.At(i), true
}

func (v *float64Vector) Type() FieldType {
	return vectorFieldType(v)
}

func (v *float64Vector) Extend(i int) {
	*v = append(*v, make([]float64, i)...)
}

func (v *float64Vector) Insert(i int, val interface{}) {
	switch {
	case i < v.Len():
		v.Extend(1)
		copy((*v)[i+1:], (*v)[i:])
		v.Set(i, val)
	case i == v.Len():
		v.Append(val)
	case i > v.Len():
		panic("Invalid index; vector length should be greater or equal to that index")
	}
}

func (v *float64Vector) Delete(i int) {
	*v = append((*v)[:i], (*v)[i+1:]...)
}

type stringVector []string

func newStringVector(n int) *stringVector {
	v := stringVector(make([]string, n))
	return &v
}

func newStringVectorWithValues(s []string) *stringVector {
	v := make([]string, len(s))
	copy(v, s)
	return (*stringVector)(&v)
}

func (v *stringVector) Set(idx int, i interface{}) {
	(*v)[idx] = i.(string)
}

func (v *stringVector) SetConcrete(idx int, i interface{}) {
	v.Set(idx, i)
}

func (v *stringVector) Append(i interface{}) {
	*v = append(*v, i.(string))
}

func (v *stringVector) At(i int) interface{} {
	return (*v)[i]
}

func (v *stringVector) PointerAt(i int) interface{} {
	return &(*v)[i]
}

func (v *stringVector) Len() int {
	return len(*v)
}

func (v *stringVector) CopyAt(i int) interface{} {
	var g string
	g = (*v)[i]
	return g
}

func (v *stringVector) ConcreteAt(i int) (interface{}, bool) {
	return v.At(i), true
}

func (v *stringVector) Type() FieldType {
	return vectorFieldType(v)
}

func (v *stringVector) Extend(i int) {
	*v = append(*v, make([]string, i)...)
}

func (v *stringVector) Insert(i int, val interface{}) {
	switch {
	case i < v.Len():
		v.Extend(1)
		copy((*v)[i+1:], (*v)[i:])
		v.Set(i, val)
	case i == v.Len():
		v.Append(val)
	case i > v.Len():
		panic("Invalid index; vector length should be greater or equal to that index")
	}
}

func (v *stringVector) Delete(i int) {
	*v = append((*v)[:i], (*v)[i+1:]...)
}

type boolVector []bool

func newBoolVector(n int) *boolVector {
	v := boolVector(make([]bool, n))
	return &v
}

func newBoolVectorWithValues(s []bool) *boolVector {
	v := make([]bool, len(s))
	copy(v, s)
	return (*boolVector)(&v)
}

func (v *boolVector) Set(idx int, i interface{}) {
	(*v)[idx] = i.(bool)
}

func (v *boolVector) SetConcrete(idx int, i interface{}) {
	v.Set(idx, i)
}

func (v *boolVector) Append(i interface{}) {
	*v = append(*v, i.(bool))
}

func (v *boolVector) At(i int) interface{} {
	return (*v)[i]
}

func (v *boolVector) PointerAt(i int) interface{} {
	return &(*v)[i]
}

func (v *boolVector) Len() int {
	return len(*v)
}

func (v *boolVector) CopyAt(i int) interface{} {
	var g bool
	g = (*v)[i]
	return g
}

func (v *boolVector) ConcreteAt(i int) (interface{}, bool) {
	return v.At(i), true
}

func (v *boolVector) Type() FieldType {
	return vectorFieldType(v)
}

func (v *boolVector) Extend(i int) {
	*v = append(*v, make([]bool, i)...)
}

func (v *boolVector) Insert(i int, val interface{}) {
	switch {
	case i < v.Len():
		v.Extend(1)
		copy((*v)[i+1:], (*v)[i:])
		v.Set(i, val)
	case i == v.Len():
		v.Append(val)
	case i > v.Len():
		panic("Invalid index; vector length should be greater or equal to that index")
	}
}

func (v *boolVector) Delete(i int) {
	*v = append((*v)[:i], (*v)[i+1:]...)
}

type timeTimeVector []time.Time

func newTimeTimeVector(n int) *timeTimeVector {
	v := timeTimeVector(make([]time.Time, n))
	return &v
}

func newTimeTimeVectorWithValues(s []time.Time) *timeTimeVector {
	v := make([]time.Time, len(s))
	copy(v, s)
	return (*timeTimeVector)(&v)
}

func (v *timeTimeVector) Set(idx int, i interface{}) {
	(*v)[idx] = i.(time.Time)
}

func (v *timeTimeVector) SetConcrete(idx int, i interface{}) {
	v.Set(idx, i)
}

func (v *timeTimeVector) Append(i interface{}) {
	*v = append(*v, i.(time.Time))
}

func (v *timeTimeVector) At(i int) interface{} {
	return (*v)[i]
}

func (v *timeTimeVector) PointerAt(i int) interface{} {
	return &(*v)[i]
}

func (v *timeTimeVector) Len() int {
	return len(*v)
}

func (v *timeTimeVector) CopyAt(i int) interface{} {
	var g time.Time
	g = (*v)[i]
	return g
}

func (v *timeTimeVector) ConcreteAt(i int) (interface{}, bool) {
	return v.At(i), true
}

func (v *timeTimeVector) Type() FieldType {
	return vectorFieldType(v)
}

func (v *timeTimeVector) Extend(i int) {
	*v = append(*v, make([]time.Time, i)...)
}

func (v *timeTimeVector) Insert(i int, val interface{}) {
	switch {
	case i < v.Len():
		v.Extend(1)
		copy((*v)[i+1:], (*v)[i:])
		v.Set(i, val)
	case i == v.Len():
		v.Append(val)
	case i > v.Len():
		panic("Invalid index; vector length should be greater or equal to that index")
	}
}

func (v *timeTimeVector) Delete(i int) {
	*v = append((*v)[:i], (*v)[i+1:]...)
}

type jsonRawMessageVector []json.RawMessage

func newJsonRawMessageVector(n int) *jsonRawMessageVector {
	v := jsonRawMessageVector(make([]json.RawMessage, n))
	return &v
}

func newJsonRawMessageVectorWithValues(s []json.RawMessage) *jsonRawMessageVector {
	v := make([]json.RawMessage, len(s))
	copy(v, s)
	return (*jsonRawMessageVector)(&v)
}

func (v *jsonRawMessageVector) Set(idx int, i interface{}) {
	(*v)[idx] = i.(json.RawMessage)
}

func (v *jsonRawMessageVector) SetConcrete(idx int, i interface{}) {
	v.Set(idx, i)
}

func (v *jsonRawMessageVector) Append(i interface{}) {
	*v = append(*v, i.(json.RawMessage))
}

func (v *jsonRawMessageVector) At(i int) interface{} {
	return (*v)[i]
}

func (v *jsonRawMessageVector) PointerAt(i int) interface{} {
	return &(*v)[i]
}

func (v *jsonRawMessageVector) Len() int {
	return len(*v)
}

func (v *jsonRawMessageVector) CopyAt(i int) interface{} {
	var g json.RawMessage
	g = (*v)[i]
	return g
}

func (v *jsonRawMessageVector) ConcreteAt(i int) (interface{}, bool) {
	return v.At(i), true
}

func (v *jsonRawMessageVector) Type() FieldType {
	return vectorFieldType(v)
}

func (v *jsonRawMessageVector) Extend(i int) {
	*v = append(*v, make([]json.RawMessage, i)...)
}

func (v *jsonRawMessageVector) Insert(i int, val interface{}) {
	switch {
	case i < v.Len():
		v.Extend(1)
		copy((*v)[i+1:], (*v)[i:])
		v.Set(i, val)
	case i == v.Len():
		v.Append(val)
	case i > v.Len():
		panic("Invalid index; vector length should be greater or equal to that index")
	}
}

func (v *jsonRawMessageVector) Delete(i int) {
	*v = append((*v)[:i], (*v)[i+1:]...)
}
